## 0. Blurb

**Apparent Purpose** The `covertreex` package implements a parallel compressed cover tree (PCCT) runtime, exposing a user-facing facade (`covertreex/api/pcct.py:45`) and multiple CLIs (new Typer-based entrypoints in `cli/pcct/main.py:21` plus the legacy benchmark runner in `cli/queries/app.py:16`) to build, benchmark, and audit tree-based nearest-neighbour workloads with residual-correlation metrics. 

**Tech Stack** Everything is written in Python: core math and traversal kernels are heavily vectorised and optionally JAX-backed (`covertreex/core/tree.py:27`) or Numba-accelerated (`covertreex/algo/_scope_numba.py:12`), configuration is driven by Pydantic models (`covertreex/runtime/model.py:296`), YAML profiles (`profiles/loader.py:61`), and Typer CLI apps plus ancillary scripts share telemetry/logging utilities. Tests and tooling rely on numpy/random datasets and pytest fixtures, and optional dependencies include JAX, numba, matplotlib, and PyYAML.

**Apparent Maturity** The codebase is structured with modular packages, telemetry, and CI-friendly hooks; exhaustive unit/integration coverage exists for algorithms (`tests/test_conflict_graph.py:56`), pipeline determinism (`tests/integration/test_parallel_update.py:139`), and CLI/telemetry flows (`tests/test_cli_queries_telemetry.py:58`), indicating production-hardening alongside observability features like `BenchmarkLogWriter` (`covertreex/telemetry/logs.py:126`).

## 1. File Tree

Numbers in parentheses denote line counts captured via `wc -l`.

```text
cli/ — Typer-based command-line frontends
├── pcct/ — new PCCT CLI composed of Typer apps
│   ├── __init__.py (13) — Functions: __getattr__
│   ├── __main__.py (4) — Module helpers/constants
│   ├── benchmark_cli.py (185) — Functions: benchmark
│   ├── build_cli.py (177) — Functions: build
│   ├── doctor.py (316) — Classes: KernelCapability, DoctorMessage, DoctorReport; Functions: doctor
│   ├── execution.py (146) — Classes: BenchmarkRun; Functions: benchmark_run
│   ├── help_panels.py (9) — Module helpers/constants
│   ├── main.py (57) — Functions: pcct_callback, main
│   ├── option_defs.py (539) — Module helpers/constants
│   ├── options.py (30) — Functions: resolve_metric_flag
│   ├── plugins_cli.py (45) — Functions: plugins
│   ├── profile.py (109) — Functions: list_profiles, describe_profile
│   ├── query.py (134) — Functions: execute_query_benchmark
│   ├── query_cli.py (141) — Functions: query
│   └── telemetry_cli.py (307) — Classes: OutputFormat, ShowSection; Functions: render_telemetry
├── queries/ — legacy benchmark CLI and telemetry plumbing
│   ├── __init__.py (16) — Module helpers/constants
│   ├── __main__.py (4) — Module helpers/constants
│   ├── app.py (855) — Classes: QueryCLIOptions; Functions: disable_legacy_entrypoint_warning, enable_legacy_entrypoint_warning, cli
│   ├── baselines.py (107) — Classes: BaselineComparison; Functions: run_baseline_comparisons
│   ├── benchmark.py (257) — Classes: QueryBenchmarkResult; Functions: benchmark_knn_latency
│   ├── gate.py (53) — Functions: _append_gate_profile_log
│   ├── runtime.py (143) — Functions: _gate_active_for_backend, _ensure_thread_env_defaults, _thread_env_snapshot
│   └── telemetry.py (348) — Classes: CLITelemetryHandles, ResidualTraversalTelemetry; Functions: initialise_cli_telemetry
├── __init__.py (5) — Command-line entrypoints for covertreex utilities.
├── runtime.py (206) — Functions: runtime_from_args
└── runtime_breakdown.py (842) — Classes: ImplementationResult; Functions: main
covertreex/ — core parallel compressed cover tree library
├── algo/ — low-level traversal/conflict kernels and numba routines
│   ├── batch/ — batch insert planning helpers
│   │   ├── __init__.py (21) — Module helpers/constants
│   │   ├── insert.py (630) — Functions: plan_batch_insert, batch_insert, batch_insert_prefix_doubling
│   │   └── types.py (53) — Classes: LevelSummary, BatchInsertTimings, BatchInsertPlan
│   ├── conflict/ — conflict graph builders and strategies
│   │   ├── __init__.py (9) — Module helpers/constants
│   │   ├── arena.py (103) — Classes: ConflictArena, ScopeBuilderArena; Functions: get_conflict_arena, get_scope_builder_arena
│   │   ├── base.py (112) — Classes: ConflictGraph, ConflictGraphTimings, ConflictGraphContext
│   │   ├── builders.py (819) — Classes: AdjacencyBuild; Functions: block_until_ready, build_dense_adjacency, build_segmented_adjacency
│   │   ├── runner.py (517) — Functions: build_conflict_graph
│   │   └── strategies.py (192) — Classes: _DenseConflictStrategy, _SegmentedConflictStrategy, _GridConflictStrategy; Functions: register_conflict_strategy, deregister_conflict_strategy, registered_conflict_strategies
│   ├── order/ — batch ordering heuristics
│   │   ├── __init__.py (12) — Module helpers/constants
│   │   ├── helpers.py (71) — Functions: prepare_batch_points, choose_prefix_factor, prefix_slices
│   │   └── strategy.py (102) — Classes: BatchOrderResult; Functions: compute_batch_order
│   ├── traverse/ — tree traversal strategy selection
│   │   ├── strategies/ — per-metric traversal strategy implementations
│   │   │   ├── __init__.py (20) — Module helpers/constants
│   │   │   ├── common.py (33) — Functions: _collect_next_chain
│   │   │   ├── euclidean.py (426) — Classes: _EuclideanDenseTraversal, _EuclideanSparseTraversal; Functions: _collect_euclidean_dense, _collect_euclidean_sparse, _ensure_parent_in_selection
│   │   │   ├── registry.py (96) — Classes: _TraversalStrategySpec; Functions: register_traversal_strategy, deregister_traversal_strategy, registered_traversal_strategies
│   │   │   └── residual.py (1839) — Classes: _ResidualTraversal; Functions: _residual_find_parents, _process_level_cache_hits, _collect_residual_scopes_streaming_serial
│   │   ├── __init__.py (19) — Module helpers/constants
│   │   ├── base.py (132) — Classes: ResidualTraversalCache, TraversalResult, TraversalTimings; Functions: block_until_ready, broadcast_batch, collect_distances
│   │   └── runner.py (47) — Functions: traverse_collect_scopes
│   ├── __init__.py (41) — Algorithmic kernels for traversal, conflict graph construction, and MIS routines.
│   ├── _grid_numba.py (267) — Functions: grid_select_leaders_numba, grid_select_leaders_numba
│   ├── _mis_numba.py (139) — Functions: run_mis_numba
│   ├── _residual_scope_numba.py (778) — Functions: residual_scope_append, residual_scope_append_bitset, residual_scope_reset
│   ├── _scope_numba.py (1420) — Classes: ScopeAdjacencyResult, ChunkRangeStats; Functions: warmup_scope_builder, filter_csr_by_radii_from_pairwise, build_conflict_graph_numba_dense
│   ├── _traverse_numba.py (128) — Functions: build_scopes_with_chains, build_scopes_numba
│   ├── _traverse_sparse_numba.py (347) — Functions: collect_sparse_scopes, collect_sparse_scopes_csr
│   ├── batch_delete.py (689) — Classes: DeleteLevelSummary, BatchDeletePlan; Functions: plan_batch_delete, batch_delete
│   ├── batch_insert.py (23) — Module helpers/constants
│   ├── batch_order.py (5) — Module helpers/constants
│   ├── mis.py (208) — Classes: MISResult; Functions: batch_mis_seeds, run_mis
│   └── semisort.py (111) — Classes: GroupByResult; Functions: group_by_int, select_topk_by_level
├── api/ — runtime and facade APIs for PCCT operations
│   ├── __init__.py (13) — Public ergonomic façade for covertreex.
│   ├── pcct.py (143) — Classes: PCCT; Functions: _ensure_points, _ensure_indices, _convert_tree
│   └── runtime.py (419) — Classes: Residual, Runtime; Functions: _maybe_tuple, _apply_if_present, _active_runtime_config
├── core/ — data structures, persistence, and metrics accessors
│   ├── __init__.py (42) — Core data structures and persistence primitives for the PCCT.
│   ├── _persistence_numba.py (116) — Functions: apply_journal_cow
│   ├── metrics.py (241) — Classes: PairwiseKernel, PointwiseKernel, Metric; Functions: get_metric, configure_residual_metric, reset_residual_metric
│   ├── persistence.py (567) — Classes: SliceUpdate, JournalScratchPool, PersistenceJournal; Functions: clone_array_segment, clone_tree_with_updates, build_persistence_journal
│   └── tree.py (317) — Classes: TreeBackend, TreeLogStats, PCCTree; Functions: get_runtime_backend, compute_level_offsets
├── metrics/ — residual-correlation metric implementations
│   ├── residual/ — residual backend, policy, and numpy helpers
│   │   ├── __init__.py (29) — Module helpers/constants
│   │   ├── _gate_profile_numba.py (111) — Functions: update_quantile_reservoir
│   │   ├── core.py (1046) — Classes: KernelProvider, PointDecoder, ResidualCorrHostData; Functions: set_residual_backend, get_residual_backend, decode_indices
│   │   ├── host_backend.py (149) — Functions: build_residual_backend
│   │   ├── policy.py (407) — Classes: ResidualGateTelemetry, ResidualGateProfile, ResidualGateLookup; Functions: get_residual_policy
│   │   └── scope_caps.py (100) — Classes: ResidualScopeCapTable; Functions: get_scope_cap_table, reset_scope_cap_cache
│   ├── __init__.py (37) — Metric-specific helpers for Covertreex.
│   └── _residual_numba.py (391) — Functions: compute_distance_chunk, gate1_whitened_mask, distance_block_no_gate
├── plugins/ — plugin registration for traversal/conflict/metrics
│   ├── __init__.py (5) — Module helpers/constants
│   ├── _loader.py (33) — Functions: load_entrypoint_plugins
│   ├── conflict.py (61) — Functions: load_entrypoints, list_plugins
│   ├── metrics.py (47) — Functions: load_entrypoints, list_metrics
│   └── traversal.py (67) — Functions: load_entrypoints, list_plugins
├── queries/ — tree query execution helpers
│   ├── __init__.py (5) — Query algorithms (k-NN, radius search) built on top of the PCCT.
│   ├── _knn_numba.py (455) — Classes: NumbaTreeView; Functions: materialise_tree_view, knn_numba, materialise_tree_view_cached
│   └── knn.py (302) — Classes: _ChildChainCache; Functions: knn, nearest_neighbor
├── runtime/ — runtime configuration/context/logging
│   ├── __init__.py (38) — Runtime configuration, logging, and diagnostics utilities for covertreex.
│   ├── config.py (345) — Classes: RuntimeConfig, RuntimeContext; Functions: current_runtime_context, runtime_context, runtime_config
│   ├── diagnostics.py (289) — Classes: OperationMetrics; Functions: log_operation
│   ├── logging.py (42) — Project-wide logging utilities that honour `RuntimeConfig`.
│   └── model.py (832) — Typed runtime configuration models and env parsing helpers.
├── telemetry/ — artifact/log schemas and helpers
│   ├── __init__.py (43) — Module helpers/constants
│   ├── artifacts.py (74) — Functions: artifact_root, resolve_artifact_path, timestamped_artifact
│   ├── logs.py (379) — Classes: BenchmarkLogWriter, ResidualScopeCapRecorder; Functions: _read_rss_bytes, _ms, _summarise_metric
│   └── schemas.py (247) — Classes: BenchmarkBatchRecord; Functions: runtime_breakdown_fieldnames
├── __init__.py (49) — Parallel compressed cover tree library.
├── baseline.py (581) — Classes: BaselineNode, BaselineCoverTree, ExternalCoverTreeBaseline; Functions: has_external_cover_tree, has_gpboost_cover_tree
├── config.py (11) — Backwards-compatible shim for the runtime configuration helpers.
├── diagnostics.py (9) — Compatibility shim for :mod:`covertreex.runtime.diagnostics`.
├── exceptions.py (6) — Classes: ResidualPairwiseCacheError
└── logging.py (9) — Compatibility shim for :mod:`covertreex.runtime.logging`.
profiles/ — runtime profile definitions and loaders
├── __init__.py (33) — Module helpers/constants
├── cpu-debug.yaml (22) — Profile 'cpu-debug': Verbose CPU profile that favours deterministic ordering and INFO/DEBUG logs for smoke tests and CLI repro runs.
├── default.yaml (22) — Profile 'default': Baseline Euclidean profile for CPU hosts. Enables NumPy backends with NumPy/Numba insert paths and leaves traversal sparse heuristics disabled.
├── loader.py (119) — Classes: ProfileError, ProfileNotFoundError, ProfileFormatError; Functions: available_profiles, load_profile_definition, load_profile
├── overrides.py (57) — Classes: OverrideError; Functions: parse_override_expression, parse_override_expressions, apply_overrides_to_model
├── residual-audit.yaml (29) — Profile 'residual-audit': Residual metric with diagnostics, gate lookup auditing, and conservative resource settings for reproducible investigations.
└── residual-fast.yaml (28) — Profile 'residual-fast': Residual metric tuned for throughput. Enables sparse traversal, residual caches, and fast scope chunking with gate lookup disabled.
tests/ — unit and integration tests
├── benchmarks/ — placeholder for benchmark fixtures (currently empty)
├── integration/ — integration/system coverage
│   ├── test_parallel_delete.py (173) — Functions: test_batch_delete_restores_parent_chain_after_tail_removal, test_batch_delete_preserves_previous_versions, test_plan_batch_delete_identifies_descendants
│   ├── test_parallel_update.py (541) — Functions: test_batch_insert_numba_persistence_matches_fallback, test_plan_batch_insert_runs_pipeline, test_batch_insert_updates_level_offsets_and_stats
│   ├── test_structural_core.py (152) — Functions: test_traversal_matches_naive_computation, test_conflict_graph_matches_bruteforce_edges
│   └── test_tier_c.py (79) — Functions: test_async_batch_insert_harness
├── utils/ — shared test utilities
│   ├── __init__.py (9) — Shared test utilities for covertreex.
│   └── datasets.py (64) — Functions: gaussian_points, gaussian_dataset, rbf_kernel
├── __init__.py (1) — Module helpers/constants
├── test_api_pcct.py (103) — Functions: reset_runtime_context, test_pcct_fit_insert_knn_roundtrip, test_pcct_delete_returns_plan
├── test_baseline_tree.py (69) — Functions: test_baseline_nearest_matches_bruteforce, test_baseline_knn_matches_bruteforce, test_baseline_knn_batched_queries
├── test_benchmarks.py (254) — Functions: test_benchmark_insert_delete_smoke, test_benchmark_knn_latency_smoke, test_run_baseline_comparisons_sequential
├── test_cli_querier_guard.py (45) — Functions: test_cli_allows_euclidean_with_gate_off
├── test_cli_queries_telemetry.py (108) — Classes: _DummyTimings, _DummyPlan; Functions: test_summary_reports_pairwise_reuse_line, test_observe_plan_raises_when_pairwise_missing, test_initialise_cli_telemetry_creates_log
├── test_config.py (545) — Functions: test_runtime_config_defaults, test_runtime_context_uses_numpy_backend_by_default, test_precision_override
├── test_conflict_graph.py (867) — Functions: reset_runtime_context, test_chunk_range_builder_honours_max_segments, test_chunk_range_builder_clamps_when_chunk_target_disabled
├── test_determinism_runtime.py (84) — Functions: test_repeated_runs_share_tree_and_hash
├── test_export_benchmark_diagnostics.py (26) — Functions: test_aggregate_requires_pairwise_reuse_for_residual, test_aggregate_allows_non_residual_without_reuse
├── test_external_baseline.py (40) — Functions: test_external_baseline_knn_matches_bruteforce, test_external_baseline_nearest
├── test_knn.py (134) — Functions: test_knn_matches_bruteforce_distances, test_nearest_neighbor_handles_single_query_vector, test_knn_raises_for_empty_tree
├── test_logging.py (21) — Functions: test_logger_respects_runtime_level
├── test_logging_diagnostics.py (140) — Functions: test_batch_insert_emits_resource_log, test_batch_delete_emits_resource_log, test_knn_emits_resource_log
├── test_metrics.py (800) — Functions: test_euclidean_pairwise_matches_manual, test_euclidean_pointwise_supports_vector_inputs, test_metric_registry_registers_and_retrieves
├── test_mis.py (107) — Functions: test_run_mis_produces_independent_set, test_batch_mis_seeds_deterministic, test_batch_mis_seeds_rejects_negative
├── test_pcct_cli.py (333) — Classes: _DummyRun; Functions: test_pcct_profile_list_displays_profiles, test_pcct_profile_describe_outputs_json, test_pcct_query_subcommand_suppresses_legacy_warning
├── test_pcct_variants.py (201) — Functions: reset_runtime_context, residual_backend_config, test_knn_consistency_across_batch_orders
├── test_persistence.py (162) — Functions: test_clone_array_segment_preserves_original, test_clone_tree_with_updates_replaces_values, test_build_persistence_journal_tracks_head_updates
├── test_pipeline_placeholder.py (45) — Functions: test_placeholder_pipeline_executes
├── test_plugins.py (105) — Classes: FakeEntryPoint; Functions: test_traversal_entrypoint_loader, test_conflict_predicate_exception_falls_back, test_metric_entrypoint_loader
├── test_profiles_loader.py (50) — Functions: test_available_profiles_exposes_expected_entries, test_load_profile_returns_runtime_model, test_load_profile_missing_raises
├── test_property_strategies.py (43) — Functions: test_batch_order_returns_valid_permutation, test_batch_mis_seeds_are_deterministic
├── test_residual_gate_profile_ingest.py (49) — Functions: test_merge_profile_records
├── test_residual_guardrail_check.py (68) — Functions: test_parse_guardrail_metrics, test_evaluate_metrics_reports_failures
├── test_residual_parents.py (635) — Functions: test_residual_parent_search_skips_whitened_path_when_gate_disabled, test_scope_streaming_respects_force_whitened_flag, test_resolve_scope_limits_dense_fallback
├── test_residual_scope_caps.py (49) — Functions: test_scope_cap_table_lookup_applies_levels, test_scope_cap_cache_returns_same_instance
├── test_run_reference_benchmarks.py (48) — Functions: test_query_job_build_command, test_guardrail_job_build_command, test_select_jobs_handles_unknown
├── test_runtime_callsite_audit.py (33) — Functions: test_runtime_config_call_sites_are_explicit
├── test_scope_numba.py (62) — Functions: test_scope_builder_limits_and_orders_with_levels, test_scope_builder_limits_without_levels, test_scope_builder_orders_full_row_when_limit_disabled
├── test_semisort.py (58) — Functions: test_group_by_int_basic, test_group_by_int_empty, test_select_topk_by_level_applies_limit
├── test_traverse.py (685) — Functions: reset_runtime_context, test_traversal_assigns_nearest_parent, test_traversal_uses_tree_backend_by_default
└── test_tree.py (75) — Functions: test_empty_tree_has_expected_shapes, test_replace_returns_new_instance, test_materialise_roundtrip
tools/ — standalone maintenance scripts and diagnostics
├── __init__.py (3) — Helper scripts for covertreex development and benchmarking.
├── build_residual_gate_profile.py (141) — Functions: main
├── export_benchmark_diagnostics.py (171) — Functions: main
├── ingest_residual_gate_profile.py (278) — Classes: ProfileRecord; Functions: load_profile_records, merge_profile_records, main
├── residual_guardrail_check.py (273) — Run the 4k residual guardrail benchmark and enforce the documented thresholds.
├── residual_scaling_sweep.py (134) — Run residual benchmarks across multiple tree sizes.
└── run_reference_benchmarks.py (306) — Automate the reference PCCT benchmark suite and emit JSONL/CSV artefacts.
```

## 2. APIs

### cli/__init__.py
Command-line entrypoints for covertreex utilities.
**Imports**
- Internal: `from .runtime import runtime_from_args`
**Functions**
- None
**Classes**
- None

### cli/pcct/__init__.py
**Imports**
- Internal: None
**Functions**
- `__getattr__(name: str) -> Any` (line 8)
**Classes**
- None

### cli/pcct/__main__.py
**Imports**
- Internal: `from .main import main`
**Functions**
- None
**Classes**
- None
**Other**
- `if __name__ == '__main__'` guard (line 3)

### cli/pcct/benchmark_cli.py
**Imports**
- Internal: `from cli.queries.app import QueryCLIOptions`
- Internal: `from . import option_defs`
- Internal: `from .execution import benchmark_run`
- Internal: `from .options import resolve_metric_flag`
- Internal: `from .query import execute_query_benchmark`
**Functions**
- `benchmark(ctx: typer.Context, dimension: opts.DimensionOption=8, tree_points: opts.TreePointsOption=16384, batch_size: opts.BatchSizeOption=512, queries: opts.QueriesOption=1024, k: opts.KOption=8, seed: opts.SeedOption=0, repeat: opts.RepeatOption=3, seed_step: opts.SeedStepOption=1, run_id: opts.RunIdOption=None, profile: opts.ProfileOption=None, set_override: opts.SetOverrideOption=None, metric: opts.MetricOption='auto', baseline: opts.BaselineOption='none', build_mode: opts.BuildModeOption='batch', backend: opts.BackendOption=None, precision: opts.PrecisionOption=None, devices: opts.DevicesOption=None, enable_numba: opts.EnableNumbaOption=None, enable_sparse_traversal: opts.EnableSparseTraversalOption=None, diagnostics: opts.DiagnosticsOption=None, log_level: opts.LogLevelOption=None, global_seed: opts.GlobalSeedOption=None, mis_seed: opts.MisSeedOption=None, conflict_graph: opts.ConflictGraphOption=None, scope_segment_dedupe: opts.ScopeSegmentDedupeOption=None, scope_chunk_target: opts.ScopeChunkTargetOption=None, scope_chunk_max_segments: opts.ScopeChunkMaxSegmentsOption=None, scope_chunk_pair_merge: opts.ScopeChunkPairMergeOption=None, scope_conflict_buffer_reuse: opts.ScopeConflictBufferReuseOption=None, degree_cap: opts.DegreeCapOption=None, batch_order: opts.BatchOrderOption=None, batch_order_seed: opts.BatchOrderSeedOption=None, residual_grid_seed: opts.ResidualGridSeedOption=None, prefix_schedule: opts.PrefixScheduleOption=None, prefix_density_low: opts.PrefixDensityLowOption=None, prefix_density_high: opts.PrefixDensityHighOption=None, prefix_growth_small: opts.PrefixGrowthSmallOption=None, prefix_growth_mid: opts.PrefixGrowthMidOption=None, prefix_growth_large: opts.PrefixGrowthLargeOption=None, residual_lengthscale: opts.ResidualLengthscaleOption=1.0, residual_variance: opts.ResidualVarianceOption=1.0, residual_inducing: opts.ResidualInducingOption=512, residual_chunk_size: opts.ResidualChunkSizeOption=512, residual_stream_tile: opts.ResidualStreamTileOption=64, residual_force_whitened: opts.ResidualForceWhitenedOption=None, residual_scope_member_limit: opts.ResidualScopeMemberLimitOption=None, residual_scope_bitset: opts.ResidualScopeBitsetOption=None, residual_dynamic_query_block: opts.ResidualDynamicQueryBlockOption=None, residual_dense_scope_streamer: opts.ResidualDenseScopeStreamerOption=None, residual_masked_scope_append: opts.ResidualMaskedScopeAppendOption=None, residual_level_cache_batching: opts.ResidualLevelCacheBatchingOption=None, residual_scope_caps: opts.ResidualScopeCapsOption=None, residual_scope_cap_default: opts.ResidualScopeCapDefaultOption=None, residual_scope_cap_output: opts.ResidualScopeCapOutputOption=None, residual_scope_cap_percentile: opts.ResidualScopeCapPercentileOption=0.5, residual_scope_cap_margin: opts.ResidualScopeCapMarginOption=0.05, residual_radius_floor: opts.ResidualRadiusFloorOption=None, residual_gate: opts.ResidualGateOption='off', residual_gate_lookup_path: opts.ResidualGateLookupPathOption=_DEFAULT_GATE_LOOKUP, residual_gate_margin: opts.ResidualGateMarginOption=0.02, residual_gate_cap: opts.ResidualGateCapOption=0.0, residual_gate_alpha: opts.ResidualGateAlphaOption=None, residual_gate_eps: opts.ResidualGateEpsOption=None, residual_gate_band_eps: opts.ResidualGateBandEpsOption=None, residual_gate_keep_pct: opts.ResidualGateKeepPctOption=None, residual_gate_prune_pct: opts.ResidualGatePrunePctOption=None, residual_gate_audit: opts.ResidualGateAuditOption=None, residual_gate_profile_path: opts.ResidualGateProfilePathOption=None, residual_gate_profile_bins: opts.ResidualGateProfileBinsOption=512, residual_gate_profile_log: opts.ResidualGateProfileLogOption=None, residual_prefilter: opts.ResidualPrefilterOption=None, residual_prefilter_lookup_path: opts.ResidualPrefilterLookupPathOption=None, residual_prefilter_margin: opts.ResidualPrefilterMarginOption=None, residual_prefilter_radius_cap: opts.ResidualPrefilterRadiusCapOption=None, residual_prefilter_audit: opts.ResidualPrefilterAuditOption=None, log_file: opts.LogFileOption=None, no_log_file: opts.NoLogFileOption=False) -> None` (line 31)
**Classes**
- None
**Other**
- Constant `_DEFAULT_GATE_LOOKUP` (line 25)

### cli/pcct/build_cli.py
**Imports**
- Internal: `from cli.queries.app import QueryCLIOptions`
- Internal: `from cli.queries.benchmark import _build_tree`
- Internal: `from cli.queries.runtime import _resolve_artifact_arg`
- Internal: `from covertreex.core.tree import PCCTree`
- Internal: `from . import option_defs`
- Internal: `from .execution import benchmark_run`
- Internal: `from .options import resolve_metric_flag`
**Functions**
- `build(ctx: typer.Context, dimension: opts.DimensionOption=8, tree_points: opts.TreePointsOption=16384, batch_size: opts.BatchSizeOption=512, seed: opts.SeedOption=0, run_id: opts.RunIdOption=None, profile: opts.ProfileOption=None, set_override: opts.SetOverrideOption=None, metric: opts.MetricOption='auto', build_mode: opts.BuildModeOption='batch', backend: opts.BackendOption=None, precision: opts.PrecisionOption=None, devices: opts.DevicesOption=None, enable_numba: opts.EnableNumbaOption=None, enable_sparse_traversal: opts.EnableSparseTraversalOption=None, diagnostics: opts.DiagnosticsOption=None, log_level: opts.LogLevelOption=None, global_seed: opts.GlobalSeedOption=None, mis_seed: opts.MisSeedOption=None, conflict_graph: opts.ConflictGraphOption=None, scope_segment_dedupe: opts.ScopeSegmentDedupeOption=None, scope_chunk_target: opts.ScopeChunkTargetOption=None, scope_chunk_max_segments: opts.ScopeChunkMaxSegmentsOption=None, scope_chunk_pair_merge: opts.ScopeChunkPairMergeOption=None, scope_conflict_buffer_reuse: opts.ScopeConflictBufferReuseOption=None, degree_cap: opts.DegreeCapOption=None, batch_order: opts.BatchOrderOption=None, batch_order_seed: opts.BatchOrderSeedOption=None, residual_grid_seed: opts.ResidualGridSeedOption=None, prefix_schedule: opts.PrefixScheduleOption=None, prefix_density_low: opts.PrefixDensityLowOption=None, prefix_density_high: opts.PrefixDensityHighOption=None, prefix_growth_small: opts.PrefixGrowthSmallOption=None, prefix_growth_mid: opts.PrefixGrowthMidOption=None, prefix_growth_large: opts.PrefixGrowthLargeOption=None, residual_lengthscale: opts.ResidualLengthscaleOption=1.0, residual_variance: opts.ResidualVarianceOption=1.0, residual_inducing: opts.ResidualInducingOption=512, residual_chunk_size: opts.ResidualChunkSizeOption=512, residual_stream_tile: opts.ResidualStreamTileOption=64, residual_force_whitened: opts.ResidualForceWhitenedOption=None, residual_scope_member_limit: opts.ResidualScopeMemberLimitOption=None, residual_scope_bitset: opts.ResidualScopeBitsetOption=None, residual_dynamic_query_block: opts.ResidualDynamicQueryBlockOption=None, residual_dense_scope_streamer: opts.ResidualDenseScopeStreamerOption=None, residual_masked_scope_append: opts.ResidualMaskedScopeAppendOption=None, residual_level_cache_batching: opts.ResidualLevelCacheBatchingOption=None, residual_scope_caps: opts.ResidualScopeCapsOption=None, residual_scope_cap_default: opts.ResidualScopeCapDefaultOption=None, residual_scope_cap_output: opts.ResidualScopeCapOutputOption=None, residual_scope_cap_percentile: opts.ResidualScopeCapPercentileOption=0.5, residual_scope_cap_margin: opts.ResidualScopeCapMarginOption=0.05, residual_radius_floor: opts.ResidualRadiusFloorOption=None, residual_gate: opts.ResidualGateOption='off', residual_gate_lookup_path: opts.ResidualGateLookupPathOption=_DEFAULT_GATE_LOOKUP, residual_gate_margin: opts.ResidualGateMarginOption=0.02, residual_gate_cap: opts.ResidualGateCapOption=0.0, residual_gate_alpha: opts.ResidualGateAlphaOption=None, residual_gate_eps: opts.ResidualGateEpsOption=None, residual_gate_band_eps: opts.ResidualGateBandEpsOption=None, residual_gate_keep_pct: opts.ResidualGateKeepPctOption=None, residual_gate_prune_pct: opts.ResidualGatePrunePctOption=None, residual_gate_audit: opts.ResidualGateAuditOption=None, residual_gate_profile_path: opts.ResidualGateProfilePathOption=None, residual_gate_profile_bins: opts.ResidualGateProfileBinsOption=512, residual_gate_profile_log: opts.ResidualGateProfileLogOption=None, residual_prefilter: opts.ResidualPrefilterOption=None, residual_prefilter_lookup_path: opts.ResidualPrefilterLookupPathOption=None, residual_prefilter_margin: opts.ResidualPrefilterMarginOption=None, residual_prefilter_radius_cap: opts.ResidualPrefilterRadiusCapOption=None, residual_prefilter_audit: opts.ResidualPrefilterAuditOption=None, log_file: opts.LogFileOption=None, no_log_file: opts.NoLogFileOption=False, export_tree: opts.ExportTreeOption=None) -> None` (line 45)
- `_export_tree_npz(tree: PCCTree, path: str) -> None` (line 30)
**Classes**
- None
**Other**
- Constant `_DEFAULT_GATE_LOOKUP` (line 25)

### cli/pcct/doctor.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.api import Runtime`
- Internal: `from covertreex.telemetry import artifact_root`
- Internal: `from profiles.loader import ProfileError`
- Internal: `from profiles.overrides import OverrideError`
- Internal: `from cli.queries.runtime import _thread_env_snapshot`
- Internal: `from covertreex.algo._mis_numba import NUMBA_AVAILABLE`
- Internal: `from covertreex.algo._grid_numba import NUMBA_GRID_AVAILABLE`
- Internal: `from covertreex.algo._scope_numba import NUMBA_SCOPE_AVAILABLE`
- Internal: `from covertreex.algo._residual_scope_numba import NUMBA_RESIDUAL_SCOPE_AVAILABLE`
- Internal: `from covertreex.algo._traverse_numba import NUMBA_TRAVERSAL_AVAILABLE`
- Internal: `from covertreex.core._persistence_numba import NUMBA_PERSISTENCE_AVAILABLE`
- Internal: `from covertreex.metrics._residual_numba import NUMBA_RESIDUAL_AVAILABLE`
- Internal: `from covertreex.queries._knn_numba import NUMBA_QUERY_AVAILABLE`
**Functions**
- `doctor(profile: str=typer.Option('default', '--profile', help="Profile to inspect (defaults to 'default')."), set_override: Optional[List[str]]=typer.Option(None, '--set', metavar='PATH=VALUE', help='Apply dot-path overrides when loading the profile.'), fail_on_warning: bool=typer.Option(False, '--fail-on-warning', help='Return exit code 1 when warnings are emitted.')) -> None` (line 280)
- `_is_residual_metric(cfg: cx_config.RuntimeConfig) -> bool` (line 55)
- `_load_runtime(profile: str, overrides: Optional[List[str]]) -> ApiRuntime` (line 148)
- `_emit_runtime_overview(cfg: cx_config.RuntimeConfig, *, profile: str, overrides: Optional[List[str]]) -> None` (line 156)
- `_check_numba(cfg: cx_config.RuntimeConfig, report: DoctorReport) -> None` (line 169)
- `_check_jax(cfg: cx_config.RuntimeConfig, report: DoctorReport) -> None` (line 206)
- `_check_artifact_root(report: DoctorReport) -> None` (line 239)
- `_check_threads(report: DoctorReport) -> None` (line 263)
- `_emit_platform_metadata() -> None` (line 272)
**Classes**
- `KernelCapability` (line 48)
  - None
- `DoctorMessage` (line 113)
  - None
- `DoctorReport` (line 119)
  - `add(self, status: str, label: str, detail: str) -> None` (line 123)
  - `render(self) -> None` (line 126)
  - `exit_code(self, *, fail_on_warning: bool) -> int` (line 138)
  - `__init__(self) -> None` (line 120)
**Other**
- Constant `_NUMBA_CAPABILITIES` (line 60)

### cli/pcct/execution.py
**Imports**
- Internal: `from covertreex import config, reset_residual_metric`
- Internal: `from covertreex.api import Runtime`
- Internal: `from covertreex.telemetry import generate_run_id, timestamped_artifact`
- Internal: `from cli.runtime import runtime_from_args`
- Internal: `from cli.queries.gate import _append_gate_profile_log`
- Internal: `from cli.queries.runtime import _ensure_thread_env_defaults, _thread_env_snapshot, _resolve_artifact_arg, _validate_residual_runtime`
- Internal: `from cli.queries.telemetry import CLITelemetryHandles, initialise_cli_telemetry`
**Functions**
- `benchmark_run(args: Any, *, benchmark: str, metadata: Mapping[str, Any]) -> Iterator[BenchmarkRun]` (line 83)
- `_prepare_residual_gate_artifacts(args: Any, run_id: str) -> tuple[Optional[str], Optional[str]]` (line 54)
**Classes**
- `BenchmarkRun` (line 23)
  - `log_writer(self)` (line 38)
  - `log_path(self) -> Optional[str]` (line 42)
  - `scope_cap_recorder(self)` (line 46)
  - `telemetry_view(self)` (line 50)

### cli/pcct/help_panels.py
**Imports**
- Internal: None
**Functions**
- None
**Classes**
- None
**Other**
- Constant `SHAPE_PANEL` (line 3)
- Constant `RUNTIME_PANEL` (line 4)
- Constant `RESIDUAL_PANEL` (line 5)
- Constant `GATE_PANEL` (line 6)
- Constant `TELEMETRY_PANEL` (line 7)

### cli/pcct/main.py
**Imports**
- Internal: `from cli.queries.app import app, disable_legacy_entrypoint_warning`
- Internal: `from .benchmark_cli import benchmark_app`
- Internal: `from .build_cli import build_app`
- Internal: `from .doctor import app`
- Internal: `from .profile import app`
- Internal: `from .plugins_cli import plugins_app`
- Internal: `from .query_cli import query_app`
- Internal: `from .telemetry_cli import telemetry_app`
**Functions**
- `pcct_callback() -> None` (line 31)
- `main() -> None` (line 53)
**Classes**
- None
**Other**
- Constant `_HELP` (line 16)

### cli/pcct/option_defs.py
**Imports**
- Internal: `from .help_panels import GATE_PANEL, RESIDUAL_PANEL, RUNTIME_PANEL, SHAPE_PANEL, TELEMETRY_PANEL`
**Functions**
- None
**Classes**
- None

### cli/pcct/options.py
**Imports**
- Internal: `from covertreex.api import Runtime`
- Internal: `from profiles.loader import ProfileError`
- Internal: `from profiles.overrides import OverrideError`
**Functions**
- `resolve_metric_flag(metric: Literal['auto', 'euclidean', 'residual'], *, profile: Optional[str], overrides: Optional[List[str]]) -> Literal['euclidean', 'residual']` (line 10)
**Classes**
- None

### cli/pcct/plugins_cli.py
**Imports**
- Internal: `from covertreex.plugins import conflict`
- Internal: `from covertreex.plugins import metrics`
- Internal: `from covertreex.plugins import traversal`
**Functions**
- `plugins() -> None` (line 36)
- `_format_rows() -> list[str]` (line 17)
**Classes**
- None

### cli/pcct/profile.py
**Imports**
- Internal: `from profiles.loader import ProfileError, ProfileMetadata, available_profiles, load_profile_definition`
**Functions**
- `list_profiles() -> None` (line 53)
- `describe_profile(name: str, output_format: str=typer.Option('yaml', '--format', '-f', case_sensitive=False, help='Output format (yaml or json).')) -> None` (line 77)
- `_render_table(headers: Sequence[str], rows: Sequence[Sequence[str]]) -> str` (line 24)
- `_format_tags(tags: Iterable[str]) -> str` (line 41)
- `_condense_text(value: str | None) -> str` (line 46)
**Classes**
- None

### cli/pcct/query.py
**Imports**
- Internal: `from covertreex.metrics import build_residual_backend, configure_residual_correlation`
- Internal: `from cli.queries.baselines import run_baseline_comparisons`
- Internal: `from cli.queries.benchmark import QueryBenchmarkResult, benchmark_knn_latency`
- Internal: `from cli.queries.runtime import _emit_engine_banner, _gate_active_for_backend`
- Internal: `from tests.utils.datasets import gaussian_points`
- Internal: `from .execution import BenchmarkRun`
**Functions**
- `execute_query_benchmark(options: 'QueryCLIOptions', run: BenchmarkRun) -> QueryBenchmarkResult` (line 72)
- `_generate_datasets(options: 'QueryCLIOptions') -> tuple[np.ndarray, np.ndarray]` (line 21)
- `_run_residual_backend(options: 'QueryCLIOptions', points: np.ndarray, *, context) -> tuple[str, bool]` (line 29)
- `_print_baseline_results(options: 'QueryCLIOptions', points: np.ndarray, queries: np.ndarray, benchmark_result) -> None` (line 47)
**Classes**
- None

### cli/pcct/query_cli.py
**Imports**
- Internal: `from cli.queries.app import QueryCLIOptions`
- Internal: `from cli.pcct.execution import benchmark_run`
- Internal: `from cli.pcct.query import execute_query_benchmark`
- Internal: `from . import option_defs`
- Internal: `from .options import resolve_metric_flag`
**Functions**
- `query(ctx: typer.Context, dimension: opts.DimensionOption=8, tree_points: opts.TreePointsOption=16384, batch_size: opts.BatchSizeOption=512, queries: opts.QueriesOption=1024, k: opts.KOption=8, seed: opts.SeedOption=0, run_id: opts.RunIdOption=None, profile: opts.ProfileOption=None, set_override: opts.SetOverrideOption=None, metric: opts.MetricOption='auto', backend: opts.BackendOption=None, precision: opts.PrecisionOption=None, devices: opts.DevicesOption=None, enable_numba: opts.EnableNumbaOption=None, enable_sparse_traversal: opts.EnableSparseTraversalOption=None, diagnostics: opts.DiagnosticsOption=None, log_level: opts.LogLevelOption=None, global_seed: opts.GlobalSeedOption=None, mis_seed: opts.MisSeedOption=None, conflict_graph: opts.ConflictGraphOption=None, scope_segment_dedupe: opts.ScopeSegmentDedupeOption=None, scope_chunk_target: opts.ScopeChunkTargetOption=None, scope_chunk_max_segments: opts.ScopeChunkMaxSegmentsOption=None, scope_chunk_pair_merge: opts.ScopeChunkPairMergeOption=None, scope_conflict_buffer_reuse: opts.ScopeConflictBufferReuseOption=None, degree_cap: opts.DegreeCapOption=None, batch_order: opts.BatchOrderOption=None, batch_order_seed: opts.BatchOrderSeedOption=None, residual_grid_seed: opts.ResidualGridSeedOption=None, prefix_schedule: opts.PrefixScheduleOption=None, prefix_density_low: opts.PrefixDensityLowOption=None, prefix_density_high: opts.PrefixDensityHighOption=None, prefix_growth_small: opts.PrefixGrowthSmallOption=None, prefix_growth_mid: opts.PrefixGrowthMidOption=None, prefix_growth_large: opts.PrefixGrowthLargeOption=None, residual_lengthscale: opts.ResidualLengthscaleOption=1.0, residual_variance: opts.ResidualVarianceOption=1.0, residual_inducing: opts.ResidualInducingOption=512, residual_chunk_size: opts.ResidualChunkSizeOption=512, residual_stream_tile: opts.ResidualStreamTileOption=64, residual_force_whitened: opts.ResidualForceWhitenedOption=None, residual_scope_member_limit: opts.ResidualScopeMemberLimitOption=None, residual_scope_bitset: opts.ResidualScopeBitsetOption=None, residual_dynamic_query_block: opts.ResidualDynamicQueryBlockOption=None, residual_dense_scope_streamer: opts.ResidualDenseScopeStreamerOption=None, residual_masked_scope_append: opts.ResidualMaskedScopeAppendOption=None, residual_level_cache_batching: opts.ResidualLevelCacheBatchingOption=None, residual_scope_caps: opts.ResidualScopeCapsOption=None, residual_scope_cap_default: opts.ResidualScopeCapDefaultOption=None, residual_scope_cap_output: opts.ResidualScopeCapOutputOption=None, residual_scope_cap_percentile: opts.ResidualScopeCapPercentileOption=0.5, residual_scope_cap_margin: opts.ResidualScopeCapMarginOption=0.05, residual_radius_floor: opts.ResidualRadiusFloorOption=None, residual_gate: opts.ResidualGateOption='off', residual_gate_lookup_path: opts.ResidualGateLookupPathOption=_DEFAULT_GATE_LOOKUP, residual_gate_margin: opts.ResidualGateMarginOption=0.02, residual_gate_cap: opts.ResidualGateCapOption=0.0, residual_gate_alpha: opts.ResidualGateAlphaOption=None, residual_gate_eps: opts.ResidualGateEpsOption=None, residual_gate_band_eps: opts.ResidualGateBandEpsOption=None, residual_gate_keep_pct: opts.ResidualGateKeepPctOption=None, residual_gate_prune_pct: opts.ResidualGatePrunePctOption=None, residual_gate_audit: opts.ResidualGateAuditOption=None, residual_gate_profile_path: opts.ResidualGateProfilePathOption=None, residual_gate_profile_bins: opts.ResidualGateProfileBinsOption=512, residual_gate_profile_log: opts.ResidualGateProfileLogOption=None, residual_prefilter: opts.ResidualPrefilterOption=None, residual_prefilter_lookup_path: opts.ResidualPrefilterLookupPathOption=None, residual_prefilter_margin: opts.ResidualPrefilterMarginOption=None, residual_prefilter_radius_cap: opts.ResidualPrefilterRadiusCapOption=None, residual_prefilter_audit: opts.ResidualPrefilterAuditOption=None, baseline: opts.BaselineOption='none', log_file: opts.LogFileOption=None, no_log_file: opts.NoLogFileOption=False, build_mode: opts.BuildModeOption='batch') -> None` (line 25)
**Classes**
- None
**Other**
- Constant `_DEFAULT_GATE_LOOKUP` (line 20)

### cli/pcct/telemetry_cli.py
**Imports**
- Internal: `from covertreex.telemetry import BenchmarkBatchRecord`
**Functions**
- `render_telemetry(log: Path=typer.Argument(..., exists=True, readable=True, help='Path to a benchmark JSONL log.'), output_format: OutputFormat=typer.Option(OutputFormat.json, '--format', '-f', case_sensitive=False, help='Output format for the summary (json, md, csv).'), show: List[ShowSection]=typer.Option(None, '--show', help='Include supplementary sections.')) -> None` (line 36)
- `_load_records(path: Path) -> List[BenchmarkBatchRecord]` (line 67)
- `_numeric_series(records: Iterable[BenchmarkBatchRecord], key: str) -> np.ndarray` (line 79)
- `_summarise(values: np.ndarray) -> Mapping[str, float] | Mapping[str, float | int]` (line 88)
- `_build_summary(records: List[BenchmarkBatchRecord]) -> dict` (line 104)
- `_residual_summary(records: List[BenchmarkBatchRecord]) -> dict` (line 145)
- `_gate_summary(records: List[BenchmarkBatchRecord]) -> dict` (line 167)
- `_pairwise_reuse(records: List[BenchmarkBatchRecord]) -> float | None` (line 182)
- `_render_markdown(summary: Mapping[str, object]) -> str` (line 194)
- `_render_csv(summary: Mapping[str, object]) -> str` (line 269)
**Classes**
- `OutputFormat` (line 16) (bases: str, enum.Enum)
  - None
- `ShowSection` (line 22) (bases: str, enum.Enum)
  - None

### cli/queries/__init__.py
**Imports**
- Internal: `from .app import QueryCLIOptions, main, run_queries`
- Internal: `from .baselines import BaselineComparison, run_baseline_comparisons`
- Internal: `from .benchmark import QueryBenchmarkResult, _build_tree, benchmark_knn_latency`
**Functions**
- None
**Classes**
- None

### cli/queries/__main__.py
**Imports**
- Internal: `from . import main`
**Functions**
- None
**Classes**
- None
**Other**
- `if __name__ == '__main__'` guard (line 3)

### cli/queries/app.py
**Imports**
- Internal: `from cli.pcct.execution import benchmark_run`
- Internal: `from cli.pcct.query import execute_query_benchmark`
**Functions**
- `disable_legacy_entrypoint_warning() -> None` (line 120)
- `enable_legacy_entrypoint_warning() -> None` (line 127)
- `cli(ctx: typer.Context, dimension: Annotated[int, typer.Option('--dimension', help='Dimensionality of tree/query points.', rich_help_panel=_SHAPE_PANEL)]=8, tree_points: Annotated[int, typer.Option('--tree-points', help='Number of points inserted before querying.', rich_help_panel=_SHAPE_PANEL)]=16384, batch_size: Annotated[int, typer.Option('--batch-size', help='Insertion batch size.', rich_help_panel=_SHAPE_PANEL)]=512, queries: Annotated[int, typer.Option('--queries', help='Number of query points per run.', rich_help_panel=_SHAPE_PANEL)]=1024, k: Annotated[int, typer.Option('--k', help='Number of neighbours requested per query.', rich_help_panel=_SHAPE_PANEL)]=8, seed: Annotated[int, typer.Option('--seed', help='Base random seed for point/query generation.', rich_help_panel=_SHAPE_PANEL)]=0, run_id: Annotated[Optional[str], typer.Option('--run-id', help='Optional run identifier propagated to telemetry artifacts.', rich_help_panel=_TELEMETRY_PANEL)]=None, profile: Annotated[Optional[str], typer.Option('--profile', help='Load a runtime profile from `profiles/` instead of manual flag overrides.', rich_help_panel=_RUNTIME_PANEL)]=None, set_override: Annotated[Optional[List[str]], typer.Option('--set', metavar='PATH=VALUE', help='Apply dot-path overrides (repeatable) when using --profile.', rich_help_panel=_RUNTIME_PANEL)]=None, metric: Annotated[Literal['euclidean', 'residual'], typer.Option('--metric', case_sensitive=False, help='Distance metric to benchmark.', rich_help_panel=_RUNTIME_PANEL)]='euclidean', backend: Annotated[Optional[str], typer.Option('--backend', help='Runtime backend (default inferred from metric).', rich_help_panel=_RUNTIME_PANEL)]=None, precision: Annotated[Optional[str], typer.Option('--precision', help='Backend precision override (float32, float64, ...).', rich_help_panel=_RUNTIME_PANEL)]=None, devices: Annotated[Optional[List[str]], typer.Option('--device', '-d', help='Restrict execution to specific logical devices.', rich_help_panel=_RUNTIME_PANEL)]=None, enable_numba: Annotated[Optional[bool], typer.Option('--enable-numba/--disable-numba', help='Force-enable or disable Numba kernels.', rich_help_panel=_RUNTIME_PANEL)]=None, enable_sparse_traversal: Annotated[Optional[bool], typer.Option('--enable-sparse-traversal/--disable-sparse-traversal', help='Toggle sparse traversal engines when supported.', rich_help_panel=_RUNTIME_PANEL)]=None, diagnostics: Annotated[Optional[bool], typer.Option('--enable-diagnostics/--disable-diagnostics', help='Control resource polling + diagnostic logging.', rich_help_panel=_RUNTIME_PANEL)]=None, log_level: Annotated[Optional[str], typer.Option('--log-level', help='Override runtime log level.', rich_help_panel=_RUNTIME_PANEL)]=None, global_seed: Annotated[Optional[int], typer.Option('--global-seed', help='Base SeedPack seed applied when channel-specific seeds are omitted.', rich_help_panel=_RUNTIME_PANEL)]=None, mis_seed: Annotated[Optional[int], typer.Option('--mis-seed', help='Sticky MIS seed when reproducing deterministic traversals.', rich_help_panel=_RUNTIME_PANEL)]=None, conflict_graph: Annotated[Optional[str], typer.Option('--conflict-graph', help='Conflict graph implementation (dense, grid, auto, ...).', rich_help_panel=_RUNTIME_PANEL)]=None, scope_segment_dedupe: Annotated[Optional[bool], typer.Option('--scope-segment-dedupe/--no-scope-segment-dedupe', help='Enable dedupe for scope chunk emission.', rich_help_panel=_RUNTIME_PANEL)]=None, scope_chunk_target: Annotated[Optional[int], typer.Option('--scope-chunk-target', help='Override scope chunk target (guards scanning depth).', rich_help_panel=_RUNTIME_PANEL)]=None, scope_chunk_max_segments: Annotated[Optional[int], typer.Option('--scope-chunk-max-segments', help='Upper bound on concurrent scope chunk segments.', rich_help_panel=_RUNTIME_PANEL)]=None, scope_chunk_pair_merge: Annotated[Optional[bool], typer.Option('--scope-chunk-pair-merge/--no-scope-chunk-pair-merge', help='Merge scope chunks based on pair-count heuristics.', rich_help_panel=_RUNTIME_PANEL)]=None, scope_conflict_buffer_reuse: Annotated[Optional[bool], typer.Option('--scope-conflict-buffer-reuse/--no-scope-conflict-buffer-reuse', help='Reuse conflict-builder buffers when using Numba scopes.', rich_help_panel=_RUNTIME_PANEL)]=None, degree_cap: Annotated[Optional[int], typer.Option('--degree-cap', help='Limit conflict-graph degree per node (0 disables).', rich_help_panel=_RUNTIME_PANEL)]=None, batch_order: Annotated[Optional[Literal['natural', 'random', 'hilbert']], typer.Option('--batch-order', help='Override insertion order (default: runtime config).', rich_help_panel=_RUNTIME_PANEL)]=None, batch_order_seed: Annotated[Optional[int], typer.Option('--batch-order-seed', help='Seed used when --batch-order=random.', rich_help_panel=_RUNTIME_PANEL)]=None, residual_grid_seed: Annotated[Optional[int], typer.Option('--residual-grid-seed', help='Seed used by residual grid leader selection.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_schedule: Annotated[Optional[Literal['doubling', 'adaptive']], typer.Option('--prefix-schedule', help='Prefix-doubling schedule override.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_density_low: Annotated[Optional[float], typer.Option('--prefix-density-low', help='Lower density bound for adaptive prefix.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_density_high: Annotated[Optional[float], typer.Option('--prefix-density-high', help='Upper density bound for adaptive prefix.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_growth_small: Annotated[Optional[float], typer.Option('--prefix-growth-small', help='Small-cluster growth factor.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_growth_mid: Annotated[Optional[float], typer.Option('--prefix-growth-mid', help='Mid-cluster growth factor.', rich_help_panel=_RUNTIME_PANEL)]=None, prefix_growth_large: Annotated[Optional[float], typer.Option('--prefix-growth-large', help='Large-cluster growth factor.', rich_help_panel=_RUNTIME_PANEL)]=None, residual_lengthscale: Annotated[float, typer.Option('--residual-lengthscale', help='Synthetic residual RBF lengthscale.', rich_help_panel=_RESIDUAL_PANEL)]=1.0, residual_variance: Annotated[float, typer.Option('--residual-variance', help='Synthetic residual RBF variance.', rich_help_panel=_RESIDUAL_PANEL)]=1.0, residual_inducing: Annotated[int, typer.Option('--residual-inducing', help='Number of inducing points in synthetic backend.', rich_help_panel=_RESIDUAL_PANEL)]=512, residual_chunk_size: Annotated[int, typer.Option('--residual-chunk-size', help='Residual kernel chunk size.', rich_help_panel=_RESIDUAL_PANEL)]=512, residual_stream_tile: Annotated[Optional[int], typer.Option('--residual-stream-tile', help='Tile size for dense scope streaming (default clamps to 64).', rich_help_panel=_RESIDUAL_PANEL)]=64, residual_force_whitened: Annotated[Optional[bool], typer.Option('--residual-force-whitened/--no-residual-force-whitened', help='Force SGEMM whitening even when the gate is off.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_scope_member_limit: Annotated[Optional[int], typer.Option('--residual-scope-member-limit', help='Override residual scope membership cap (0 disables dense fallback).', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_scope_bitset: Annotated[Optional[bool], typer.Option('--residual-scope-bitset/--no-residual-scope-bitset', help='Bitset dedupe for dense residual scopes (default on).', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_dynamic_query_block: Annotated[Optional[bool], typer.Option('--residual-dynamic-query-block/--no-residual-dynamic-query-block', help='Prototype dynamic query-block sizing for residual traversal.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_dense_scope_streamer: Annotated[Optional[bool], typer.Option('--residual-dense-scope-streamer/--no-residual-dense-scope-streamer', help='Force dense scope streaming to scan each chunk once per batch.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_masked_scope_append: Annotated[Optional[bool], typer.Option('--residual-masked-scope-append/--no-residual-masked-scope-append', help='Use the Numba masked append path for dense scope streaming.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_level_cache_batching: Annotated[Optional[bool], typer.Option('--residual-level-cache-batching/--no-residual-level-cache-batching', help='Batch level-scope cache prefetching + parent-chain insertion (default on).', rich_help_panel=_RESIDUAL_PANEL)]=True, residual_scope_caps: Annotated[Optional[str], typer.Option('--residual-scope-caps', help='JSON file describing per-level radius caps.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_scope_cap_default: Annotated[Optional[float], typer.Option('--residual-scope-cap-default', help='Fallback radius cap when no per-level cap matches.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_scope_cap_output: Annotated[Optional[str], typer.Option('--residual-scope-cap-output', help='Write derived per-level scope caps to this JSON file.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_scope_cap_percentile: Annotated[float, typer.Option('--residual-scope-cap-percentile', help='Quantile (0-1) used when deriving scope caps.', rich_help_panel=_RESIDUAL_PANEL)]=0.5, residual_scope_cap_margin: Annotated[float, typer.Option('--residual-scope-cap-margin', help='Safety margin added to derived caps.', rich_help_panel=_RESIDUAL_PANEL)]=0.05, residual_radius_floor: Annotated[Optional[float], typer.Option('--residual-radius-floor', help='Lower bound for residual scope radii.', rich_help_panel=_RESIDUAL_PANEL)]=None, residual_gate: Annotated[Optional[Literal['off', 'lookup']], typer.Option('--residual-gate', help='Residual gate preset (off keeps dense path).', rich_help_panel=_GATE_PANEL)]='off', residual_gate_lookup_path: Annotated[str, typer.Option('--residual-gate-lookup-path', help='Lookup JSON when --residual-gate=lookup.', rich_help_panel=_GATE_PANEL)]='docs/data/residual_gate_profile_diag0.json', residual_gate_margin: Annotated[float, typer.Option('--residual-gate-margin', help='Lookup safety margin.', rich_help_panel=_GATE_PANEL)]=0.02, residual_gate_cap: Annotated[float, typer.Option('--residual-gate-cap', help='Optional radius cap when using lookup presets.', rich_help_panel=_GATE_PANEL)]=0.0, residual_gate_alpha: Annotated[Optional[float], typer.Option('--residual-gate-alpha', help='Manual override for Gate-1 alpha.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_eps: Annotated[Optional[float], typer.Option('--residual-gate-eps', help='Gate-1 epsilon override.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_band_eps: Annotated[Optional[float], typer.Option('--residual-gate-band-eps', help='Gate-1 band epsilon override.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_keep_pct: Annotated[Optional[float], typer.Option('--residual-gate-keep-pct', help='Gate-1 keep percentage.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_prune_pct: Annotated[Optional[float], typer.Option('--residual-gate-prune-pct', help='Gate-1 prune percentage.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_audit: Annotated[Optional[bool], typer.Option('--residual-gate-audit/--no-residual-gate-audit', help='Emit gate audit payloads.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_profile_path: Annotated[Optional[str], typer.Option('--residual-gate-profile-path', help='Write gate profile samples to this JSON file.', rich_help_panel=_GATE_PANEL)]=None, residual_gate_profile_bins: Annotated[int, typer.Option('--residual-gate-profile-bins', help='Histogram bins when recording gate profiles.', rich_help_panel=_GATE_PANEL)]=512, residual_gate_profile_log: Annotated[Optional[str], typer.Option('--residual-gate-profile-log', help='Append profile metadata to this JSONL log.', rich_help_panel=_GATE_PANEL)]=None, residual_prefilter: Annotated[Optional[bool], typer.Option('--residual-prefilter/--no-residual-prefilter', help='Enable lookup-driven residual prefilter before traversal.', rich_help_panel=_GATE_PANEL)]=None, residual_prefilter_lookup_path: Annotated[Optional[str], typer.Option('--residual-prefilter-lookup-path', help='Lookup JSON file for the residual prefilter.', rich_help_panel=_GATE_PANEL)]=None, residual_prefilter_margin: Annotated[Optional[float], typer.Option('--residual-prefilter-margin', help='Safety margin for the residual prefilter.', rich_help_panel=_GATE_PANEL)]=None, residual_prefilter_radius_cap: Annotated[Optional[float], typer.Option('--residual-prefilter-radius-cap', help='Radius cap when the prefilter is enabled.', rich_help_panel=_GATE_PANEL)]=None, residual_prefilter_audit: Annotated[Optional[bool], typer.Option('--residual-prefilter-audit/--no-residual-prefilter-audit', help='Emit prefilter audit payloads.', rich_help_panel=_GATE_PANEL)]=None, baseline: Annotated[Literal['none', 'sequential', 'gpboost', 'external', 'both', 'all'], typer.Option('--baseline', help='Run optional baseline comparisons.', rich_help_panel=_TELEMETRY_PANEL)]='none', log_file: Annotated[Optional[str], typer.Option('--log-file', help='Write per-batch telemetry JSONL to this path.', rich_help_panel=_TELEMETRY_PANEL)]=None, no_log_file: Annotated[bool, typer.Option('--no-log-file', help='Disable JSONL telemetry emission (not recommended).', rich_help_panel=_TELEMETRY_PANEL)]=False, build_mode: Annotated[Literal['batch', 'prefix'], typer.Option('--build-mode', help='Choose between batch or prefix-doubling construction.', rich_help_panel=_SHAPE_PANEL)]='batch') -> None` (line 148)
- `run_queries(options: QueryCLIOptions) -> None` (line 831)
- `main() -> None` (line 851)
- `_emit_legacy_warning_once() -> None` (line 135)
**Classes**
- `QueryCLIOptions` (line 16)
  - `from_namespace(cls, namespace: Any) -> 'QueryCLIOptions'` (line 94)
**Other**
- Constant `_LEGACY_ENTRYPOINT_WARNING_ENABLED` (line 12)
- Constant `_LEGACY_ENTRYPOINT_WARNING_EMITTED` (line 13)
- Constant `_SHAPE_PANEL` (line 113)
- Constant `_RUNTIME_PANEL` (line 114)
- Constant `_RESIDUAL_PANEL` (line 115)
- Constant `_GATE_PANEL` (line 116)
- Constant `_TELEMETRY_PANEL` (line 117)
- Constant `_LEGACY_ENTRYPOINT_WARNING_ENABLED` (line 124)
- Constant `_LEGACY_ENTRYPOINT_WARNING_ENABLED` (line 131)
- Constant `_LEGACY_ENTRYPOINT_WARNING_EMITTED` (line 132)
- Constant `_LEGACY_ENTRYPOINT_WARNING_EMITTED` (line 144)

### cli/queries/baselines.py
**Imports**
- Internal: `from covertreex.baseline import BaselineCoverTree, ExternalCoverTreeBaseline, GPBoostCoverTreeBaseline, has_external_cover_tree, has_gpboost_cover_tree`
**Functions**
- `run_baseline_comparisons(points: np.ndarray, queries: np.ndarray, *, k: int, mode: str) -> List[BaselineComparison]` (line 87)
- `_run_sequential_baseline(points: np.ndarray, queries: np.ndarray, *, k: int) -> BaselineComparison` (line 27)
- `_run_external_baseline(points: np.ndarray, queries: np.ndarray, *, k: int) -> BaselineComparison` (line 45)
- `_run_gpboost_baseline(points: np.ndarray, queries: np.ndarray, *, k: int) -> BaselineComparison` (line 65)
**Classes**
- `BaselineComparison` (line 19)
  - None

### cli/queries/benchmark.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo import batch_insert, batch_insert_prefix_doubling`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.queries.knn import knn`
- Internal: `from covertreex.telemetry import BenchmarkLogWriter, ResidualScopeCapRecorder`
- Internal: `from tests.utils.datasets import gaussian_points`
- Internal: `from .runtime import _resolve_backend`
**Functions**
- `benchmark_knn_latency(*, dimension: int, tree_points: int, query_count: int, k: int, batch_size: int, seed: int, prebuilt_points: np.ndarray | None=None, prebuilt_tree: PCCTree | None=None, prebuilt_queries: np.ndarray | None=None, build_seconds: float | None=None, log_writer: BenchmarkLogWriter | None=None, scope_cap_recorder: 'ResidualScopeCapRecorder | None'=None, build_mode: str='batch', plan_callback: Callable[[Any, int, int], Mapping[str, Any] | None] | None=None, context: cx_config.RuntimeContext | None=None) -> Tuple[PCCTree, QueryBenchmarkResult]` (line 185)
- `_ensure_context(context: cx_config.RuntimeContext | None) -> cx_config.RuntimeContext` (line 20)
- `_generate_backend_points(rng: Generator, count: int, dimension: int, *, backend: TreeBackend) -> np.ndarray` (line 37)
- `_build_tree(*, dimension: int, tree_points: int, batch_size: int, seed: int, prebuilt_points: np.ndarray | None=None, log_writer: BenchmarkLogWriter | None=None, scope_cap_recorder: 'ResidualScopeCapRecorder | None'=None, build_mode: str='batch', plan_callback: Callable[[Any, int, int], Mapping[str, Any] | None] | None=None, context: cx_config.RuntimeContext | None=None) -> Tuple[PCCTree, np.ndarray, float]` (line 48)
**Classes**
- `QueryBenchmarkResult` (line 28)
  - None

### cli/queries/gate.py
**Imports**
- Internal: `from covertreex.telemetry.schemas import RESIDUAL_GATE_PROFILE_SCHEMA_ID`
**Functions**
- `_append_gate_profile_log(*, profile_json_path: str | None, profile_log_path: str | None, run_id: str, log_metadata: Dict[str, Any], runtime_snapshot: Dict[str, Any], batch_log_path: str | None) -> None` (line 10)
**Classes**
- None

### cli/queries/runtime.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import TreeBackend`
- Internal: `from covertreex.telemetry import artifact_root, resolve_artifact_path`
**Functions**
- `_gate_active_for_backend(host_backend: Any | None) -> bool` (line 12)
- `_ensure_thread_env_defaults() -> Dict[str, str]` (line 25)
- `_thread_env_snapshot() -> Dict[str, str]` (line 44)
- `_emit_engine_banner(engine: str, gate_active: bool, threads: Dict[str, str]) -> None` (line 58)
- `_resolve_runtime_config(*, context: cx_config.RuntimeContext | None=None, runtime: cx_config.RuntimeConfig | None=None) -> cx_config.RuntimeConfig` (line 68)
- `_resolve_backend(*, context: cx_config.RuntimeContext | None=None, runtime: cx_config.RuntimeConfig | None=None) -> TreeBackend` (line 83)
- `_resolve_artifact_arg(path: str | None, *, category: str='benchmarks') -> str | None` (line 96)
- `_validate_residual_runtime(snapshot: Dict[str, Any]) -> None` (line 117)
**Classes**
- None

### cli/queries/telemetry.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.telemetry import BenchmarkLogWriter, ResidualScopeCapRecorder, timestamped_artifact`
- Internal: `from .runtime import _resolve_artifact_arg`
**Functions**
- `initialise_cli_telemetry(*, args: Any, run_id: str, runtime_snapshot: Mapping[str, Any], log_metadata: Mapping[str, Any], context: cx_config.RuntimeContext | None=None) -> CLITelemetryHandles` (line 45)
- `_resolve_runtime_config(*, context: cx_config.RuntimeContext | None=None) -> cx_config.RuntimeConfig` (line 19)
- `_median(values: np.ndarray) -> float` (line 275)
- `_percentile(values: np.ndarray, pct: float) -> float` (line 281)
- `_per_unit(numerator: float, denom: float) -> float` (line 287)
- `_format_pairs(value: float) -> str` (line 293)
- `_format_int(value: float) -> str` (line 297)
- `_format_time(seconds: float) -> str` (line 301)
- `_format_ratio(value: float) -> str` (line 314)
- `_format_scaled(value: float, suffix: str) -> str` (line 322)
- `_ratio(numerator: float, denominator: float) -> float` (line 333)
- `_share_fraction(numerator: float, denominator: float) -> float` (line 341)
**Classes**
- `CLITelemetryHandles` (line 32)
  - `close(self) -> None` (line 38)
- `ResidualTraversalTelemetry` (line 121)
  - `observe_plan(self, plan: Any, batch_index: int, batch_size: int) -> Dict[str, float] | None` (line 127)
  - `has_data(self) -> bool` (line 160)
  - `render_summary(self) -> Sequence[str]` (line 163)
  - `__init__(self) -> None` (line 124)
  - `_handle_pairwise_reuse_failure(batch_index: int, batch_size: int, flag: int) -> None` (line 262)
- `_ResidualBatchTelemetry` (line 109)
  - None

### cli/runtime.py
**Imports**
- Internal: `from covertreex.api import Runtime, Residual`
- Internal: `from profiles.loader import ProfileError`
- Internal: `from profiles.overrides import OverrideError`
**Functions**
- `runtime_from_args(args: Any, *, default_metric: str='euclidean', extra_overrides: Mapping[str, Any] | None=None) -> ApiRuntime` (line 67)
- `_get_arg(source: Any, name: str, default: Any=None) -> Any` (line 10)
- `_residual_policy_from_args(args: Any) -> ApiResidual | None` (line 16)
- `_runtime_from_profile(profile: str, overrides: Sequence[str] | None) -> ApiRuntime` (line 199)
**Classes**
- None

### cli/runtime_breakdown.py
**Imports**
- Internal: `from cli.runtime import runtime_from_args`
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo import batch_insert`
- Internal: `from covertreex.algo.mis import NUMBA_AVAILABLE`
- Internal: `from covertreex.core.tree import PCCTree, get_runtime_backend`
- Internal: `from covertreex.queries.knn import knn`
- Internal: `from covertreex.baseline import BaselineCoverTree, ExternalCoverTreeBaseline, GPBoostCoverTreeBaseline, has_external_cover_tree, has_gpboost_cover_tree`
- Internal: `from covertreex.telemetry import RUNTIME_BREAKDOWN_CHUNK_FIELDS, RUNTIME_BREAKDOWN_SCHEMA_ID, generate_run_id, resolve_artifact_path, runtime_breakdown_fieldnames, timestamped_artifact`
- Internal: `from tests.utils.datasets import gaussian_dataset`
**Functions**
- `main() -> None` (line 674)
- `_generate_dataset(*, dimension: int, tree_points: int, queries: int, seed: int) -> tuple[np.ndarray, np.ndarray]` (line 71)
- `_block_until_ready(value: object) -> None` (line 92)
- `_read_rss_bytes() -> Optional[int]` (line 107)
- `_resource_snapshot() -> _ResourceSnapshot` (line 120)
- `_resource_delta(start: _ResourceSnapshot, end: _ResourceSnapshot) -> tuple[float, float, Optional[int], Optional[int]]` (line 133)
- `_compute_cpu_utilisation(cpu_seconds: float, wall_seconds: float) -> float` (line 151)
- `_format_bytes(value: Optional[int]) -> str` (line 157)
- `_format_resource_summary(cpu_seconds: float, cpu_utilisation: float, rss_delta: Optional[int], max_rss: Optional[int]) -> str` (line 170)
- `_print_multi_run_summary(all_results: List[List[ImplementationResult]]) -> None` (line 184)
- `_temporary_runtime_override(**overrides: object) -> None` (line 219)
- `_chunk_points(points: np.ndarray, batch_size: int) -> List[np.ndarray]` (line 229)
- `_summarise_batches(batch_metrics: List[Dict[str, float]], build_seconds: float) -> Dict[str, float]` (line 233)
- `_summarise_chunk_metrics(batch_metrics: List[Dict[str, float]]) -> Dict[str, float]` (line 277)
- `_run_pcct_variant(*, label: str, points: np.ndarray, queries: np.ndarray, batch_size: int, k: int, seed: int, enable_numba: bool) -> ImplementationResult` (line 306)
- `_run_sequential_baseline(*, label: str, points: np.ndarray, queries: np.ndarray, k: int, constructor) -> ImplementationResult` (line 422)
- `_plot_results(results: List[ImplementationResult], *, output: Optional[str], show: bool) -> None` (line 472)
- `_parse_args() -> argparse.Namespace` (line 570)
**Classes**
- `ImplementationResult` (line 50)
  - None
- `_ResourceSnapshot` (line 99)
  - None
**Other**
- `if __name__ == '__main__'` guard (line 841)

### covertreex/__init__.py
Parallel compressed cover tree library.
**Imports**
- Internal: `from .core import PCCTree, TreeBackend, TreeLogStats, available_metrics, configure_residual_metric, get_metric, reset_residual_metric`
- Internal: `from .metrics.residual import ResidualCorrHostData, configure_residual_correlation`
- Internal: `from .baseline import BaselineCoverTree, BaselineNode, ExternalCoverTreeBaseline, GPBoostCoverTreeBaseline, has_external_cover_tree, has_gpboost_cover_tree`
**Functions**
- None
**Classes**
- None

### covertreex/algo/__init__.py
Algorithmic kernels for traversal, conflict graph construction, and MIS routines.
**Imports**
- Internal: `from .conflict import ConflictGraph, ConflictGraphTimings, build_conflict_graph`
- Internal: `from .mis import MISResult, batch_mis_seeds, run_mis`
- Internal: `from .traverse import TraversalResult, TraversalTimings, traverse_collect_scopes`
- Internal: `from .batch_delete import BatchDeletePlan, batch_delete, plan_batch_delete`
- Internal: `from .batch import BatchInsertPlan, BatchInsertTimings, PrefixBatchGroup, PrefixBatchResult, batch_insert, batch_insert_prefix_doubling, plan_batch_insert`
- Internal: `from .semisort import GroupByResult, group_by_int, select_topk_by_level`
**Functions**
- None
**Classes**
- None

### covertreex/algo/_grid_numba.py
**Imports**
- Internal: None
**Functions**
- `grid_select_leaders_numba(points: np.ndarray, levels: np.ndarray, *, seed: int, num_shifts: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]` (line 200)
- `grid_select_leaders_numba(*args: Any, **kwargs: Any) -> Tuple[np.ndarray, np.ndarray, np.ndarray]` (line 260)
- `_prepare_level_arrays(levels: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]` (line 23)
- `_fill_coords(points: np.ndarray, widths: np.ndarray, shift_vec: np.ndarray, coords: np.ndarray) -> None` (line 42)
- `_fill_priorities(levels_clamped: np.ndarray, seed: int, priorities: np.ndarray) -> None` (line 52)
- `_mix_uint64_scalar(value: np.uint64) -> np.uint64` (line 62)
- `_shift_vector(dim: int, seed: int) -> np.ndarray` (line 73)
- `_mark_leaders_for_shift(coords: np.ndarray, priorities: np.ndarray, leader_mask: np.ndarray, leader_priorities: np.ndarray) -> int` (line 83)
- `_gather_indices(mask: np.ndarray) -> np.ndarray` (line 132)
- `_compute_leader_priorities(leader_indices: np.ndarray, leader_priorities: np.ndarray) -> np.ndarray` (line 147)
- `_micro_mis(points: np.ndarray, base_radius: np.ndarray, leader_indices: np.ndarray, leader_priorities_subset: np.ndarray) -> Tuple[np.ndarray, int, int]` (line 158)
**Classes**
- None
**Other**
- Constant `NUMBA_GRID_AVAILABLE` (line 11)
- Constant `_UINT64_MAX` (line 16)
- Constant `_INV_TWO64` (line 17)

### covertreex/algo/_mis_numba.py
**Imports**
- Internal: None
**Functions**
- `run_mis_numba(indptr: np.ndarray, indices: np.ndarray, seed: int) -> Tuple[np.ndarray, int]` (line 134)
- `_hash_priority(node: int, seed: int, iteration: int) -> float` (line 20)
- `_max_degree(indptr: np.ndarray) -> int` (line 31)
- `_greedy_low_degree(indptr: np.ndarray, indices: np.ndarray, num_nodes: int) -> np.ndarray` (line 40)
- `_run_mis_numba_impl(indptr: np.ndarray, indices: np.ndarray, num_nodes: int, seed: int) -> Tuple[np.ndarray, int]` (line 64)
**Classes**
- None
**Other**
- Constant `NUMBA_AVAILABLE` (line 10)
- Constant `DEGREE_THRESHOLD` (line 17)

### covertreex/algo/_residual_scope_numba.py
**Imports**
- Internal: None
**Functions**
- `residual_scope_append(flags: np.ndarray, positions: np.ndarray, buffer: np.ndarray, count: int, limit: int, *, respect_limit: bool=True) -> tuple[int, int, bool]` (line 522)
- `residual_scope_append_bitset(flags: np.ndarray, bitset_row: np.ndarray, positions: np.ndarray, count: int, limit: int, *, respect_limit: bool=True) -> tuple[int, int, bool, int]` (line 547)
- `residual_scope_reset(flags: np.ndarray, buffer: np.ndarray, count: int) -> None` (line 569)
- `residual_scope_append_masked(flags: np.ndarray, buffer: np.ndarray, mask_row: np.ndarray, distances_row: np.ndarray, tile_positions: np.ndarray, count: int, limit: int, *, respect_limit: bool=True) -> tuple[int, int, bool, int, float]` (line 575)
- `residual_scope_append_masked_bitset(flags: np.ndarray, bitset_row: np.ndarray, mask_row: np.ndarray, distances_row: np.ndarray, tile_positions: np.ndarray, count: int, limit: int, *, respect_limit: bool=True) -> tuple[int, int, bool, int, float]` (line 607)
- `residual_scope_dynamic_tile_stride(base_stride: int, active_idx: np.ndarray, block_idx_arr: np.ndarray, scope_counts: np.ndarray, limit_value: int, budget_enabled: bool, budget_applied: np.ndarray, budget_limits: np.ndarray) -> int` (line 639)
- `residual_scope_update_budget_state(qi: int, chunk_points: np.ndarray, scan_cap_value: int, budget_applied: np.ndarray, budget_up: float, budget_down: float, budget_schedule: np.ndarray, budget_indices: np.ndarray, budget_limits: np.ndarray, budget_final_limits: np.ndarray, budget_escalations: np.ndarray, budget_low_streak: np.ndarray, budget_survivors: np.ndarray, budget_early_flags: np.ndarray, saturated: np.ndarray, saturated_flags: np.ndarray) -> None` (line 665)
- `residual_collect_next_chain(next_cache: np.ndarray, start: int, visited: np.ndarray, buffer: np.ndarray) -> int` (line 734)
- `_append_positions_impl(flags: np.ndarray, positions: np.ndarray, buffer: np.ndarray, count: int, limit: int, respect_limit: bool) -> tuple[int, int, int]` (line 17)
- `_append_positions_masked_impl(flags: np.ndarray, mask_row: np.ndarray, distances_row: np.ndarray, tile_positions: np.ndarray, buffer: np.ndarray, count: int, limit: int, respect_limit: bool) -> tuple[int, int, int, int, float]` (line 52)
- `_append_positions_bitset_impl(flags: np.ndarray, bitset_row: np.ndarray, positions: np.ndarray, count: int, limit: int, respect_limit: bool) -> tuple[int, int, int, int]` (line 98)
- `_append_positions_masked_bitset_impl(flags: np.ndarray, bitset_row: np.ndarray, mask_row: np.ndarray, distances_row: np.ndarray, tile_positions: np.ndarray, count: int, limit: int, respect_limit: bool) -> tuple[int, int, int, int, float]` (line 132)
- `_reset_flags_impl(flags: np.ndarray, buffer: np.ndarray, count: int) -> None` (line 174)
- `_dynamic_tile_stride_impl(base_stride: int, active_idx: np.ndarray, block_idx_arr: np.ndarray, scope_counts: np.ndarray, limit_value: int, budget_enabled: bool, budget_applied: np.ndarray, budget_limits: np.ndarray) -> int` (line 184)
- `_update_budget_state_impl(qi: int, chunk_points: np.ndarray, scan_cap_value: int, budget_applied: np.ndarray, budget_up: float, budget_down: float, budget_schedule: np.ndarray, budget_indices: np.ndarray, budget_limits: np.ndarray, budget_final_limits: np.ndarray, budget_escalations: np.ndarray, budget_low_streak: np.ndarray, budget_survivors: np.ndarray, budget_early_flags: np.ndarray, saturated: np.ndarray, saturated_flags: np.ndarray) -> None` (line 222)
- `_append_positions_impl(flags, positions, buffer, count, limit, respect_limit)` (line 282)
- `_append_positions_masked_impl(flags, mask_row, distances_row, tile_positions, buffer, count, limit, respect_limit)` (line 309)
- `_append_positions_bitset_impl(flags, bitset_row, positions, count, limit, respect_limit)` (line 354)
- `_append_positions_masked_bitset_impl(flags, bitset_row, mask_row, distances_row, tile_positions, count, limit, respect_limit)` (line 380)
- `_reset_flags_impl(flags, buffer, count)` (line 421)
- `_dynamic_tile_stride_impl(base_stride, active_idx, block_idx_arr, scope_counts, limit_value, budget_enabled, budget_applied, budget_limits)` (line 430)
- `_update_budget_state_impl(qi, chunk_points, scan_cap_value, budget_applied, budget_up, budget_down, budget_schedule, budget_indices, budget_limits, budget_final_limits, budget_escalations, budget_low_streak, budget_survivors, budget_early_flags, saturated, saturated_flags)` (line 464)
- `_collect_next_chain_impl(next_cache: np.ndarray, start: int, visited: np.ndarray, buffer: np.ndarray) -> int` (line 708)
**Classes**
- None
**Other**
- Constant `NUMBA_RESIDUAL_SCOPE_AVAILABLE` (line 8)

### covertreex/algo/_scope_numba.py
**Imports**
- Internal: `from covertreex.algo.conflict.arena import ScopeBuilderArena`
**Functions**
- `warmup_scope_builder() -> None` (line 281)
- `filter_csr_by_radii_from_pairwise(indptr: np.ndarray, indices: np.ndarray, radii: np.ndarray, pairwise: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 1020)
- `build_conflict_graph_numba_dense(scope_indptr: np.ndarray, scope_indices: np.ndarray, batch_size: int, *, segment_dedupe: bool=True, chunk_target: int=0, chunk_max_segments: int=0, pairwise: np.ndarray | None=None, radii: np.ndarray | None=None, degree_cap: int=0, scratch_pool: ScopeBuilderArena | None=None, pair_merge: bool=False) -> ScopeAdjacencyResult` (line 1047)
- `build_scope_csr_from_pairs(owners: np.ndarray, members: np.ndarray, num_nodes: int, *, limit: int=0, top_levels: np.ndarray | None=None, parents: np.ndarray | None=None) -> tuple[np.ndarray, np.ndarray]` (line 1355)
- `_chunk_ranges_from_indptr(indptr: np.ndarray, chunk_target: int, max_segments: int=0, keep_mask: np.ndarray | None=None, pair_counts: np.ndarray | None=None, pair_merge: bool=False) -> tuple[list[tuple[int, int]], ChunkRangeStats]` (line 59)
- `_merge_tail_ranges(ranges: list[tuple[int, int]], weights_prefix: np.ndarray, chunk_cap: int, tail_threshold: int, *, pair_prefix: np.ndarray | None=None, pair_cap: int=0, pair_tail_threshold: int=0) -> list[tuple[int, int]]` (line 173)
- `_merge_ranges_by_pair_volume(ranges: list[tuple[int, int]], pair_prefix: np.ndarray, pair_cap: int) -> tuple[list[tuple[int, int]], int]` (line 225)
- `_max_range_pairs(ranges: list[tuple[int, int]], pair_prefix: np.ndarray | None) -> int` (line 258)
- `_require_numba() -> None` (line 269)
- `_select_topk_by_index(indices: np.ndarray, limit: int) -> np.ndarray` (line 315)
- `_select_topk_by_level(indices: np.ndarray, top_levels: np.ndarray, limit: int) -> np.ndarray` (line 327)
- `_contains_value(values: np.ndarray, needle: int) -> bool` (line 357)
- `_build_scope_csr_from_pairs_impl(owners: np.ndarray, members: np.ndarray, num_nodes: int, limit: int, top_levels: np.ndarray, parents: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 366)
- `_membership_point_ids_from_indptr(indptr: np.ndarray, total: int) -> np.ndarray` (line 464)
- `_group_by_key_counting(keys: np.ndarray, vals: np.ndarray, K: int)` (line 475)
- `_sort_segments_inplace(values: np.ndarray, indptr: np.ndarray)` (line 496)
- `_hash_segments(values: np.ndarray, indptr: np.ndarray) -> np.ndarray` (line 506)
- `_segments_equal(values: np.ndarray, indptr: np.ndarray, a: int, b: int) -> bool` (line 521)
- `_dedupe_segments_by_hash(values: np.ndarray, indptr: np.ndarray, hashes: np.ndarray) -> np.ndarray` (line 535)
- `_compute_pair_counts(indptr: np.ndarray, keep: np.ndarray)` (line 555)
- `_prefix_sum(arr: np.ndarray)` (line 576)
- `_expand_pairs(values: np.ndarray, indptr: np.ndarray, keep: np.ndarray, offsets: np.ndarray, src: np.ndarray, dst: np.ndarray)` (line 586)
- `_dedup_pairs_undirected(src: np.ndarray, dst: np.ndarray)` (line 613)
- `_expand_pairs_directed_impl(values: np.ndarray, indptr: np.ndarray, kept_nodes: np.ndarray, offsets: np.ndarray, pairwise: np.ndarray, radii: np.ndarray, reuse_sources: np.ndarray, reuse_targets: np.ndarray, reuse_enabled: int)` (line 655)
- `_expand_pairs_directed_capped_impl(values: np.ndarray, indptr: np.ndarray, kept_nodes: np.ndarray, offsets: np.ndarray, pairwise: np.ndarray, radii: np.ndarray, degree_cap: int, reuse_sources: np.ndarray, reuse_targets: np.ndarray, reuse_enabled: int)` (line 706)
- `_expand_pairs_directed(values: np.ndarray, indptr: np.ndarray, kept_nodes: np.ndarray, offsets: np.ndarray, pairwise: np.ndarray, radii: np.ndarray, degree_cap: int, reuse_sources: np.ndarray, reuse_targets: np.ndarray, reuse_enabled: int)` (line 769)
- `_expand_pairs_chunked_to_csr(values: np.ndarray, indptr: np.ndarray, keep_mask: np.ndarray, chunk_ranges: np.ndarray, pairwise: np.ndarray, radii: np.ndarray, batch_size: int, degree_cap: int, counts_buffer: np.ndarray, degree_buffer: np.ndarray, reuse_enabled: int, indices_buffer: np.ndarray) -> tuple[np.ndarray, np.ndarray, int, int, int, int]` (line 808)
- `_pairs_to_csr(sources: np.ndarray, targets: np.ndarray, offsets: np.ndarray, used: np.ndarray, batch_size: int)` (line 944)
- `_count_edges_within_radius(indptr: np.ndarray, indices: np.ndarray, radii: np.ndarray, pairwise: np.ndarray) -> np.ndarray` (line 992)
- `_prefix_sum64(x: np.ndarray) -> np.ndarray` (line 1009)
- `_build_scope_csr_from_pairs_impl(owners: np.ndarray, members: np.ndarray, num_nodes: int, limit: int, top_levels: np.ndarray, parents: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 1343)
**Classes**
- `ScopeAdjacencyResult` (line 24)
  - None
- `ChunkRangeStats` (line 48)
  - None
**Other**
- Constant `NUMBA_SCOPE_AVAILABLE` (line 12)
- Constant `I32` (line 17)
- Constant `I64` (line 18)
- Constant `U8` (line 19)
- Constant `U64` (line 20)
- Constant `_TAIL_MERGE_DIVISOR` (line 56)
- Constant `_SCOPE_WARMED` (line 278)
- Constant `_SCOPE_WARMED` (line 310)
- Constant `N` (line 477)
- Constant `L` (line 528)
- Constant `E` (line 614)

### covertreex/algo/_traverse_numba.py
**Imports**
- Internal: None
**Functions**
- `build_scopes_with_chains(mask: np.ndarray, parents: np.ndarray, next_cache: np.ndarray, top_levels: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 102)
- `build_scopes_numba(mask: np.ndarray, parents: np.ndarray, next_cache: np.ndarray, top_levels: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 112)
- `_require_numba() -> None` (line 16)
- `_mark_next_chains(mask: np.ndarray, parents: np.ndarray, next_cache: np.ndarray) -> None` (line 28)
- `_sort_scope_nodes(nodes: np.ndarray, top_levels: np.ndarray) -> None` (line 47)
- `_mask_to_csr(mask: np.ndarray, top_levels: np.ndarray) -> tuple[np.ndarray, np.ndarray]` (line 63)
**Classes**
- None
**Other**
- Constant `NUMBA_TRAVERSAL_AVAILABLE` (line 8)
- Constant `I64` (line 13)

### covertreex/algo/_traverse_sparse_numba.py
**Imports**
- Internal: `from covertreex.queries._knn_numba import NumbaTreeView`
**Functions**
- `collect_sparse_scopes(view: NumbaTreeView, queries: np.ndarray, parents: np.ndarray, radii: np.ndarray) -> PyList[np.ndarray]` (line 292)
- `collect_sparse_scopes_csr(view: NumbaTreeView, queries: np.ndarray, parents: np.ndarray, radii: np.ndarray, chunk_target: int) -> Tuple[np.ndarray, np.ndarray, int, int, int]` (line 324)
- `_sqdist_row(query: np.ndarray, point: np.ndarray) -> float` (line 25)
- `_cover_radius(index: int, top_levels: np.ndarray, si_cache: np.ndarray) -> float` (line 33)
- `_collect_scope_single_into(query: np.ndarray, parent: int, radius: float, points: np.ndarray, top_levels: np.ndarray, si_cache: np.ndarray, children_offsets: np.ndarray, children_list: np.ndarray, roots: np.ndarray, next_cache: np.ndarray, out_buf: np.ndarray) -> int` (line 42)
- `_collect_scope_single(query: np.ndarray, parent: int, radius: float, points: np.ndarray, top_levels: np.ndarray, si_cache: np.ndarray, children_offsets: np.ndarray, children_list: np.ndarray, roots: np.ndarray, next_cache: np.ndarray) -> np.ndarray` (line 153)
- `_collect_scopes_csr(queries: np.ndarray, parents: np.ndarray, radii: np.ndarray, points: np.ndarray, top_levels: np.ndarray, si_cache: np.ndarray, children_offsets: np.ndarray, children_list: np.ndarray, roots: np.ndarray, next_cache: np.ndarray, chunk_target: int) -> Tuple[np.ndarray, np.ndarray, int, int, int]` (line 183)
- `_collect_scope_single_into(*_args, **_kwargs)` (line 282)
- `_collect_scope_single(*_args, **_kwargs)` (line 285)
- `_collect_scopes_csr(*_args, **_kwargs)` (line 288)
**Classes**
- None
**Other**
- Constant `NUMBA_SPARSE_TRAVERSAL_AVAILABLE` (line 12)
- Constant `_EPS` (line 20)

### covertreex/algo/batch/__init__.py
**Imports**
- Internal: `from .insert import batch_insert, batch_insert_prefix_doubling, plan_batch_insert`
- Internal: `from .types import BatchInsertPlan, BatchInsertTimings, LevelSummary, PrefixBatchGroup, PrefixBatchResult`
**Functions**
- None
**Classes**
- None

### covertreex/algo/batch/insert.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.conflict import ConflictGraph, build_conflict_graph`
- Internal: `from covertreex.algo.mis import MISResult, batch_mis_seeds, run_mis`
- Internal: `from covertreex.algo.order import compute_batch_order, choose_prefix_factor, prepare_batch_points, prefix_slices`
- Internal: `from covertreex.algo.traverse import TraversalResult, traverse_collect_scopes`
- Internal: `from covertreex.core.metrics import get_metric`
- Internal: `from covertreex.core.persistence import apply_persistence_journal, build_persistence_journal`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend, TreeLogStats`
- Internal: `from covertreex.diagnostics import log_operation`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from .types import BatchInsertPlan, BatchInsertTimings, LevelSummary, PrefixBatchGroup, PrefixBatchResult`
**Functions**
- `plan_batch_insert(tree: PCCTree, batch_points: Any, *, backend: Optional[TreeBackend]=None, mis_seed: int | None=None, apply_batch_order: bool=True, context: cx_config.RuntimeContext | None=None) -> BatchInsertPlan` (line 43)
- `batch_insert(tree: PCCTree, batch_points: Any, *, backend: Optional[TreeBackend]=None, mis_seed: int | None=None, apply_batch_order: bool | None=None, context: cx_config.RuntimeContext | None=None) -> tuple[PCCTree, BatchInsertPlan]` (line 136)
- `batch_insert_prefix_doubling(tree: PCCTree, batch_points: Any, *, backend: Optional[TreeBackend]=None, mis_seed: int | None=None, shuffle_seed: int | None=None, context: cx_config.RuntimeContext | None=None) -> tuple[PCCTree, PrefixBatchResult]` (line 497)
- `_batch_insert_impl(op_log: Any, tree: PCCTree, batch_points: Any, *, backend: TreeBackend, mis_seed: int | None, apply_batch_order: bool | None, context: cx_config.RuntimeContext | None) -> tuple[PCCTree, BatchInsertPlan]` (line 161)
**Classes**
- None
**Other**
- Constant `LOG_EPS` (line 386)
- Constant `LOG_EPS` (line 434)
- Constant `LOGGER` (line 630)

### covertreex/algo/batch/types.py
**Imports**
- Internal: `from covertreex.algo.conflict import ConflictGraph`
- Internal: `from covertreex.algo.mis import MISResult`
- Internal: `from covertreex.algo.traverse import TraversalResult`
**Functions**
- None
**Classes**
- `LevelSummary` (line 12)
  - None
- `BatchInsertTimings` (line 20)
  - None
- `BatchInsertPlan` (line 27)
  - None
- `PrefixBatchGroup` (line 41)
  - None
- `PrefixBatchResult` (line 49)
  - None

### covertreex/algo/batch_delete.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.batch import plan_batch_insert`
- Internal: `from covertreex.algo.mis import batch_mis_seeds`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend, TreeLogStats, compute_level_offsets`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from covertreex.diagnostics import log_operation`
**Functions**
- `plan_batch_delete(tree: PCCTree, remove_indices: Any, *, backend: Optional[TreeBackend]=None) -> BatchDeletePlan` (line 570)
- `batch_delete(tree: PCCTree, remove_indices: Any, *, backend: Optional[TreeBackend]=None, context: cx_config.RuntimeContext | None=None) -> Tuple[PCCTree, BatchDeletePlan]` (line 628)
- `_build_child_links_from_parents(parents_np: np.ndarray) -> Tuple[np.ndarray, np.ndarray]` (line 75)
- `_ensure_2d(points: np.ndarray, dimension: int) -> np.ndarray` (line 87)
- `_collect_descendants(parents_np: np.ndarray) -> List[List[int]]` (line 95)
- `_compute_delete_computation(tree: PCCTree, remove_indices: Any, *, backend: Optional[TreeBackend]=None, context: cx_config.RuntimeContext | None=None) -> _DeleteComputation` (line 105)
- `_build_plan_from_computation(backend: TreeBackend, computation: _DeleteComputation) -> BatchDeletePlan` (line 527)
- `_materialise_tree_from_computation(tree: PCCTree, backend: TreeBackend, computation: _DeleteComputation) -> PCCTree` (line 581)
- `_batch_delete_impl(op_log: Any, tree: PCCTree, remove_indices: Any, *, backend: TreeBackend, context: cx_config.RuntimeContext | None) -> Tuple[PCCTree, BatchDeletePlan]` (line 649)
**Classes**
- `DeleteLevelSummary` (line 26)
  - None
- `BatchDeletePlan` (line 37)
  - None
- `_DeleteLevelSummaryData` (line 47)
  - None
- `_DeleteComputation` (line 58)
  - None
**Other**
- Constant `LOGGER` (line 22)
- Constant `LOG_EPS` (line 406)

### covertreex/algo/batch_insert.py
**Imports**
- Internal: `from .batch import BatchInsertPlan, BatchInsertTimings, LevelSummary, PrefixBatchGroup, PrefixBatchResult, batch_insert, batch_insert_prefix_doubling, plan_batch_insert`
**Functions**
- None
**Classes**
- None

### covertreex/algo/batch_order.py
**Imports**
- Internal: `from .order import BatchOrderResult, compute_batch_order`
**Functions**
- None
**Classes**
- None

### covertreex/algo/conflict/__init__.py
**Imports**
- Internal: `from .base import ConflictGraph, ConflictGraphTimings`
- Internal: `from .runner import build_conflict_graph`
- Internal: `from covertreex.plugins import conflict`
**Functions**
- None
**Classes**
- None

### covertreex/algo/conflict/arena.py
**Imports**
- Internal: None
**Functions**
- `get_conflict_arena() -> ConflictArena` (line 90)
- `get_scope_builder_arena() -> ScopeBuilderArena` (line 94)
**Classes**
- `ConflictArena` (line 25)
  - `borrow_sources(self, size: int) -> np.ndarray` (line 31)
  - `borrow_targets(self, size: int) -> np.ndarray` (line 34)
  - `total_bytes(self) -> int` (line 38)
- `ScopeBuilderArena` (line 46)
  - `borrow_counts(self, size: int) -> np.ndarray` (line 55)
  - `borrow_degree_usage(self, size: int) -> np.ndarray` (line 61)
  - `borrow_sources(self, size: int) -> np.ndarray` (line 67)
  - `borrow_targets(self, size: int) -> np.ndarray` (line 70)
  - `borrow_indices(self, size: int) -> np.ndarray` (line 73)
  - `total_bytes(self) -> int` (line 77)
- `_ArenaBuffer` (line 9)
  - `ensure(self, size: int) -> np.ndarray` (line 12)
  - `capacity_bytes(self) -> int` (line 20)
**Other**
- Constant `_CONFLICT_ARENA` (line 42)
- Constant `_SCOPE_BUILDER_ARENA` (line 87)

### covertreex/algo/conflict/base.py
**Imports**
- Internal: `from covertreex.core.tree import TreeBackend`
**Functions**
- None
**Classes**
- `ConflictGraph` (line 15)
  - `num_nodes(self) -> int` (line 38)
  - `num_edges(self) -> int` (line 42)
  - `num_scopes(self) -> int` (line 46)
- `ConflictGraphTimings` (line 51)
  - None
- `ConflictGraphContext` (line 91)
  - None
- `ConflictGraphStrategy` (line 110) (bases: Protocol)
  - `build(self, ctx: ConflictGraphContext) -> 'AdjacencyBuild'` (line 111)

### covertreex/algo/conflict/builders.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo._grid_numba import NUMBA_GRID_AVAILABLE, grid_select_leaders_numba`
- Internal: `from covertreex.algo._scope_numba import NUMBA_SCOPE_AVAILABLE, build_conflict_graph_numba_dense, warmup_scope_builder`
- Internal: `from covertreex.algo.semisort import group_by_int`
- Internal: `from .arena import get_conflict_arena, get_scope_builder_arena`
- Internal: `from covertreex.core.tree import TreeBackend`
**Functions**
- `block_until_ready(value: Any) -> None` (line 33)
- `build_dense_adjacency(*, backend: TreeBackend, batch_size: int, scope_indptr: Any, scope_indices: Any, pairwise: Any | None=None, radii: np.ndarray | None=None, residual_pairwise: np.ndarray | None=None, chunk_target_override: int | None=None, runtime: cx_config.RuntimeConfig | None=None) -> AdjacencyBuild` (line 76)
- `build_segmented_adjacency(*, backend: TreeBackend, scope_indices: Any, point_ids: Any, pairwise_np: np.ndarray, radii_np: np.ndarray) -> AdjacencyBuild` (line 475)
- `build_residual_adjacency(*, backend: TreeBackend, batch_size: int, scope_indptr: Any, scope_indices: Any, pairwise: Any | None, radii: np.ndarray | None, residual_pairwise: np.ndarray, chunk_target_override: int | None=None, runtime: cx_config.RuntimeConfig | None=None) -> AdjacencyBuild` (line 558)
- `build_grid_adjacency(*, backend: TreeBackend, batch_points: Any, batch_levels: Any, radii: Any, scope_indptr: Any, scope_indices: Any, runtime: cx_config.RuntimeConfig | None=None) -> AdjacencyBuild` (line 583)
- `_resolve_runtime_config(runtime: cx_config.RuntimeConfig | None) -> cx_config.RuntimeConfig` (line 24)
- `_grid_select_leaders(*, points: np.ndarray, levels: np.ndarray, radii: np.ndarray, seed: int, num_shifts: int=3) -> tuple[np.ndarray, np.ndarray, Dict[str, int]]` (line 703)
- `_shift_vector(dim: int, seed: int) -> np.ndarray` (line 797)
- `_mix_uint64(values: np.ndarray) -> np.ndarray` (line 802)
**Classes**
- `AdjacencyBuild` (line 40)
  - None

### covertreex/algo/conflict/runner.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo._scope_numba import NUMBA_SCOPE_AVAILABLE, filter_csr_by_radii_from_pairwise`
- Internal: `from covertreex.algo.semisort import group_by_int`
- Internal: `from covertreex.algo.traverse import TraversalResult`
- Internal: `from covertreex.core.metrics import get_metric`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.metrics.residual import ResidualDistanceTelemetry, ResidualWorkspace, compute_residual_distances_from_kernel, compute_residual_distances_with_radius, compute_residual_pairwise_matrix, decode_indices, get_residual_backend`
- Internal: `from covertreex.exceptions import ResidualPairwiseCacheError`
- Internal: `from .base import ConflictGraph, ConflictGraphContext, ConflictGraphTimings`
- Internal: `from .builders import block_until_ready`
- Internal: `from .strategies import select_conflict_strategy`
**Functions**
- `build_conflict_graph(tree: PCCTree, traversal: TraversalResult, batch_points: Any, *, backend: TreeBackend | None=None, context: cx_config.RuntimeContext | None=None) -> ConflictGraph` (line 58)
- `_adaptive_scope_chunk_target(counts: np.ndarray) -> int | None` (line 39)
**Classes**
- None
**Other**
- Constant `_ADAPTIVE_SCOPE_PAIR_BUDGET` (line 34)
- Constant `_ADAPTIVE_SCOPE_MIN` (line 35)
- Constant `_ADAPTIVE_SCOPE_MAX` (line 36)
- Constant `RESIDUAL_FILTER_EPS` (line 517)

### covertreex/algo/conflict/strategies.py
**Imports**
- Internal: `from covertreex.logging import get_logger`
- Internal: `from .base import ConflictGraphContext, ConflictGraphStrategy`
- Internal: `from .builders import AdjacencyBuild, build_dense_adjacency, build_grid_adjacency, build_residual_adjacency, build_segmented_adjacency`
**Functions**
- `register_conflict_strategy(name: str, *, predicate: Callable[[Any, bool, bool], bool], factory: Callable[[], ConflictGraphStrategy], origin: str | None=None) -> None` (line 99)
- `deregister_conflict_strategy(name: str) -> None` (line 122)
- `registered_conflict_strategies() -> tuple[str, ...]` (line 130)
- `select_conflict_strategy(runtime: Any, *, residual_mode: bool, has_residual_distances: bool) -> ConflictGraphStrategy` (line 167)
- `describe_conflict_strategies() -> List[dict[str, str]]` (line 183)
**Classes**
- `_DenseConflictStrategy` (line 18) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext) -> AdjacencyBuild` (line 19)
- `_SegmentedConflictStrategy` (line 32) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext) -> AdjacencyBuild` (line 33)
- `_GridConflictStrategy` (line 43) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext) -> AdjacencyBuild` (line 44)
- `_ResidualGridConflictStrategy` (line 56) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext) -> AdjacencyBuild` (line 57)
- `_ResidualConflictStrategy` (line 69) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext) -> AdjacencyBuild` (line 70)
- `_ConflictStrategySpec` (line 85)
  - None
**Other**
- Constant `LOGGER` (line 93)
- Constant `_CONFLICT_REGISTRY` (line 96)
- Constant `_CONFLICT_REGISTRY` (line 109)
- Constant `_CONFLICT_REGISTRY` (line 125)

### covertreex/algo/mis.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.conflict import ConflictGraph`
- Internal: `from covertreex.core.tree import TreeBackend`
- Internal: `from covertreex.algo._mis_numba import NUMBA_AVAILABLE, run_mis_numba`
**Functions**
- `batch_mis_seeds(count: int, *, seed: int | None=None, runtime: cx_config.RuntimeConfig | None=None) -> Tuple[int, ...]` (line 50)
- `run_mis(backend: TreeBackend, graph: ConflictGraph, *, seed: int | None=None, runtime: cx_config.RuntimeConfig | None=None) -> MISResult` (line 73)
- `_resolve_runtime_config(runtime: cx_config.RuntimeConfig | None) -> cx_config.RuntimeConfig` (line 22)
- `_block_until_ready(value: Any) -> None` (line 31)
- `_repeat_nodes(indptr: jnp.ndarray, dtype) -> jnp.ndarray` (line 45)
**Classes**
- `MISResult` (line 40)
  - None
**Other**
- Constant `DEGREE_THRESHOLD` (line 15)
- Constant `_HASH_MULTIPLIER` (line 16)
- Constant `_HASH_SHIFT_1` (line 17)
- Constant `_HASH_SHIFT_2` (line 18)
- Constant `_HASH_SHIFT_3` (line 19)

### covertreex/algo/order/__init__.py
**Imports**
- Internal: `from .helpers import choose_prefix_factor, prepare_batch_points, prefix_slices`
- Internal: `from .strategy import BatchOrderResult, compute_batch_order`
**Functions**
- None
**Classes**
- None

### covertreex/algo/order/helpers.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import TreeBackend`
- Internal: `from .strategy import compute_batch_order`
**Functions**
- `prepare_batch_points(*, backend: TreeBackend, batch_points: Any, runtime: cx_config.RuntimeConfig, apply_batch_order: bool) -> tuple[Any, Optional[np.ndarray], Dict[str, float]]` (line 13)
- `choose_prefix_factor(runtime: cx_config.RuntimeConfig, domination_ratio: float) -> float` (line 51)
- `prefix_slices(length: int) -> list[tuple[int, int]]` (line 59)
**Classes**
- None

### covertreex/algo/order/strategy.py
**Imports**
- Internal: None
**Functions**
- `compute_batch_order(points: np.ndarray, *, strategy: str, seed: Optional[int]=None) -> BatchOrderResult` (line 15)
- `_hilbert_permutation(points: np.ndarray, *, seed: Optional[int]) -> tuple[np.ndarray, Dict[str, float]]` (line 38)
- `_axes_to_transpose(coords: list[int], bits: int) -> list[int]` (line 63)
- `_transpose_to_hilbert(transpose: list[int], bits: int, dims: int) -> int` (line 91)
**Classes**
- `BatchOrderResult` (line 10)
  - None
**Other**
- Constant `M` (line 66)
- Constant `Q` (line 67)
- Constant `P` (line 69)
- Constant `Q` (line 81)

### covertreex/algo/semisort.py
**Imports**
- Internal: `from covertreex.core.tree import TreeBackend`
**Functions**
- `group_by_int(keys: Any, values: Any, *, backend: TreeBackend, stable: bool=True) -> GroupByResult` (line 18)
- `select_topk_by_level(indices: np.ndarray, levels: np.ndarray, limit: int) -> np.ndarray` (line 79)
**Classes**
- `GroupByResult` (line 12)
  - None

### covertreex/algo/traverse/__init__.py
**Imports**
- Internal: `from covertreex.metrics.residual import compute_residual_pairwise_matrix`
- Internal: `from .base import ResidualTraversalCache, TraversalResult, TraversalTimings, TraversalStrategy`
- Internal: `from .runner import traverse_collect_scopes`
**Functions**
- None
**Classes**
- None

### covertreex/algo/traverse/base.py
**Imports**
- Internal: `from covertreex.core.metrics import get_metric`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
**Functions**
- `block_until_ready(value: Any) -> None` (line 89)
- `broadcast_batch(backend: TreeBackend, batch_points: Any) -> Any` (line 97)
- `collect_distances(tree: PCCTree, batch: Any, backend: TreeBackend) -> Any` (line 101)
- `empty_result(backend: TreeBackend, batch_size: int) -> TraversalResult` (line 106)
**Classes**
- `ResidualTraversalCache` (line 13)
  - None
- `TraversalResult` (line 27)
  - None
- `TraversalTimings` (line 42)
  - None
- `TraversalStrategy` (line 77) (bases: Protocol)
  - `collect(self, tree: PCCTree, batch: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 78)

### covertreex/algo/traverse/runner.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from .base import ResidualTraversalCache, TraversalResult, TraversalTimings, broadcast_batch, empty_result`
- Internal: `from .strategies import select_traversal_strategy`
**Functions**
- `traverse_collect_scopes(tree: PCCTree, batch_points: Any, *, backend: TreeBackend | None=None, context: cx_config.RuntimeContext | None=None) -> TraversalResult` (line 25)
**Classes**
- None

### covertreex/algo/traverse/strategies/__init__.py
**Imports**
- Internal: `from .registry import register_traversal_strategy, registered_traversal_strategies, select_traversal_strategy`
- Internal: `from covertreex.plugins import traversal`
- Internal: `from . import residual`
- Internal: `from . import euclidean`
**Functions**
- None
**Classes**
- None

### covertreex/algo/traverse/strategies/common.py
**Imports**
- Internal: `from covertreex.core.tree import PCCTree`
**Functions**
- `_collect_next_chain(tree: PCCTree, start: int, *, next_cache: np.ndarray | None=None) -> tuple[int, ...]` (line 8)
**Classes**
- None

### covertreex/algo/traverse/strategies/euclidean.py
**Imports**
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from covertreex.queries._knn_numba import knn_numba, materialise_tree_view_cached`
- Internal: `from ..._traverse_numba import NUMBA_TRAVERSAL_AVAILABLE, build_scopes_numba`
- Internal: `from ..._traverse_sparse_numba import NUMBA_SPARSE_TRAVERSAL_AVAILABLE, collect_sparse_scopes, collect_sparse_scopes_csr`
- Internal: `from ..._scope_numba import build_scope_csr_from_pairs`
- Internal: `from ...semisort import select_topk_by_level`
- Internal: `from ..base import TraversalResult, TraversalTimings, TraversalStrategy, block_until_ready, collect_distances, empty_result`
- Internal: `from .common import _collect_next_chain`
- Internal: `from .registry import register_traversal_strategy`
**Functions**
- `_collect_euclidean_dense(tree: PCCTree, batch: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 58)
- `_collect_euclidean_sparse(tree: PCCTree, batch_points: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 221)
- `_ensure_parent_in_selection(selection: np.ndarray, row_values: np.ndarray, parent_idx: int, top_levels_np: np.ndarray, limit: int) -> np.ndarray` (line 357)
- `_conflict_scopes_from_csr(scope_indptr: np.ndarray, scope_indices: np.ndarray) -> tuple[tuple[int, ...], ...]` (line 378)
- `_max_scope_size(scope_indptr: np.ndarray) -> int` (line 394)
**Classes**
- `_EuclideanDenseTraversal` (line 34) (bases: TraversalStrategy)
  - `collect(self, tree: PCCTree, batch: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 35)
- `_EuclideanSparseTraversal` (line 46) (bases: TraversalStrategy)
  - `collect(self, tree: PCCTree, batch: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 47)
**Other**
- Constant `LOGGER` (line 31)

### covertreex/algo/traverse/strategies/registry.py
**Imports**
- Internal: `from covertreex.core.tree import TreeBackend`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from ..base import TraversalStrategy`
**Functions**
- `register_traversal_strategy(name: str, *, predicate: Callable[[Any, TreeBackend], bool], factory: Callable[[], TraversalStrategy], origin: str | None=None) -> None` (line 26)
- `deregister_traversal_strategy(name: str) -> None` (line 51)
- `registered_traversal_strategies() -> Tuple[str, ...]` (line 61)
- `select_traversal_strategy(runtime: Any, backend: TreeBackend) -> TraversalStrategy` (line 65)
- `describe_traversal_strategies() -> List[dict[str, str]]` (line 76)
**Classes**
- `_TraversalStrategySpec` (line 15)
  - None
**Other**
- Constant `LOGGER` (line 11)
- Constant `_TRAVERSAL_REGISTRY` (line 23)
- Constant `_TRAVERSAL_REGISTRY` (line 38)
- Constant `_TRAVERSAL_REGISTRY` (line 56)

### covertreex/algo/traverse/strategies/residual.py
**Imports**
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.metrics import residual`
- Internal: `from covertreex.metrics.residual import ResidualCorrHostData, ResidualGateTelemetry, ResidualDistanceTelemetry, ResidualWorkspace, compute_residual_distances_block_no_gate, compute_residual_distances_from_kernel, compute_residual_distances_with_radius, decode_indices, get_residual_backend`
- Internal: `from covertreex.metrics.residual.scope_caps import get_scope_cap_table`
- Internal: `from ..._residual_scope_numba import residual_scope_append, residual_scope_append_bitset, residual_scope_append_masked, residual_scope_append_masked_bitset, residual_scope_reset, residual_scope_dynamic_tile_stride, residual_scope_update_budget_state, residual_collect_next_chain, NUMBA_RESIDUAL_SCOPE_AVAILABLE`
- Internal: `from ..._scope_numba import build_scope_csr_from_pairs`
- Internal: `from ...semisort import select_topk_by_level`
- Internal: `from ..base import ResidualTraversalCache, TraversalResult, TraversalTimings, TraversalStrategy, empty_result`
- Internal: `from .common import _collect_next_chain`
- Internal: `from .registry import register_traversal_strategy`
**Functions**
- `_residual_find_parents(*, host_backend: ResidualCorrHostData, query_indices: np.ndarray, tree_indices: np.ndarray, telemetry: ResidualDistanceTelemetry | None=None) -> Tuple[np.ndarray, np.ndarray]` (line 64)
- `_process_level_cache_hits(*, cache_jobs: Dict[int, List[int]], level_scope_cache: Dict[int, np.ndarray], total_points: int, tree_indices_np: np.ndarray, query_indices: np.ndarray, radii: np.ndarray, host_backend: ResidualCorrHostData, distance_telemetry: ResidualDistanceTelemetry, limit_value: int, force_whitened: bool, use_masked_append: bool, bitset_enabled: bool, scope_buffers: np.ndarray | None, scope_counts: np.ndarray, scope_bitsets: np.ndarray | None, flags_matrix: np.ndarray, budget_applied: np.ndarray, budget_survivors: np.ndarray, trimmed_flags: np.ndarray, saturated: np.ndarray, saturated_flags: np.ndarray, dedupe_hits: np.ndarray, observed_radii: np.ndarray, shared_workspace: ResidualWorkspace) -> tuple[int, int]` (line 109)
- `_collect_residual_scopes_streaming_serial(*, tree: PCCTree, host_backend: ResidualCorrHostData, query_indices: np.ndarray, tree_indices: np.ndarray, parent_positions: np.ndarray, radii: np.ndarray, scope_limit: int | None=None, scan_cap: int | None=None, scope_budget_schedule: Tuple[int, ...] | None=None, scope_budget_up_thresh: float | None=None, scope_budget_down_thresh: float | None=None, stream_tile: int | None=None, workspace: ResidualWorkspace | None=None, telemetry: ResidualDistanceTelemetry | None=None, force_whitened: bool=False, bitset_enabled: bool=False, level_cache_batching: bool=True) -> Tuple[np.ndarray, np.ndarray, Tuple[Tuple[int, ...], ...], int, int, ResidualGateTelemetry, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, int, int, int, int, int, int, int]` (line 256)
- `_collect_residual_scopes_streaming_parallel(*, tree: PCCTree, host_backend: ResidualCorrHostData, query_indices: np.ndarray, tree_indices: np.ndarray, parent_positions: np.ndarray, radii: np.ndarray, scope_limit: int | None=None, scan_cap: int | None=None, scope_budget_schedule: Tuple[int, ...] | None=None, scope_budget_up_thresh: float | None=None, scope_budget_down_thresh: float | None=None, stream_tile: int | None=None, workspace: ResidualWorkspace | None=None, telemetry: ResidualDistanceTelemetry | None=None, force_whitened: bool=False, bitset_enabled: bool=False, dynamic_query_block: bool=False, dense_scope_streamer: bool=False, masked_scope_append: bool=True, level_cache_batching: bool=True) -> Tuple[np.ndarray, np.ndarray, Tuple[Tuple[int, ...], ...], int, int, ResidualGateTelemetry, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, int, int, int, int, int, int, int, float]` (line 637)
- `_resolve_scope_limits(runtime: Any, gate_active: bool) -> Tuple[int, int]` (line 1202)
- `_update_scope_budget_state(qi: int, chunk_points: np.ndarray, scan_cap_value: int | None, budget_applied: np.ndarray, budget_up: float, budget_down: float, budget_schedule_arr: np.ndarray, budget_indices: np.ndarray, budget_limits: np.ndarray, budget_final_limits: np.ndarray, budget_escalations: np.ndarray, budget_low_streak: np.ndarray, budget_survivors: np.ndarray, budget_early_flags: np.ndarray, saturated: np.ndarray, saturated_flags: np.ndarray) -> None` (line 1235)
- `_residual_gate_active(host_backend: ResidualCorrHostData) -> bool` (line 1315)
- `_append_scope_positions(flags_row: np.ndarray, bitset_row: np.ndarray | None, positions: np.ndarray, limit_value: int, scope_count: int, *, buffer_row: np.ndarray | None=None) -> tuple[int, int, bool, int]` (line 1326)
- `_append_scope_positions_masked(*, flags_row: np.ndarray, bitset_row: np.ndarray | None, mask_row: np.ndarray, distances_row: np.ndarray, tile_positions: np.ndarray, limit_value: int, scope_count: int, buffer_row: np.ndarray | None=None) -> tuple[int, int, bool, int, float]` (line 1354)
- `_append_scope_positions_numba(flags_row: np.ndarray, buffer_row: np.ndarray, positions: np.ndarray, limit_value: int, scope_count: int) -> tuple[int, int, bool, int]` (line 1422)
- `_append_scope_positions_dense(flags_row: np.ndarray, positions: np.ndarray, limit_value: int, scope_count: int) -> tuple[int, int, bool, int]` (line 1451)
- `_append_scope_positions_bitset(flags_row: np.ndarray, bitset_row: np.ndarray, positions: np.ndarray, limit_value: int, scope_count: int) -> tuple[int, int, bool, int]` (line 1487)
- `_compute_dynamic_tile_stride(base_stride: int, active_idx: np.ndarray, block_idx_arr: np.ndarray, scope_counts: np.ndarray, limit_value: int, budget_enabled: bool, budget_applied: np.ndarray, budget_limits: np.ndarray) -> int` (line 1509)
- `_resolve_query_block_size(base_block: int, remaining_active: int) -> int` (line 1557)
- `_collect_residual(tree: PCCTree, batch_points: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 1568)
**Classes**
- `_ResidualTraversal` (line 52) (bases: TraversalStrategy)
  - `collect(self, tree: PCCTree, batch: Any, *, backend: TreeBackend, runtime: Any) -> TraversalResult` (line 53)
**Other**
- Constant `_RESIDUAL_SCOPE_EPS` (line 46)
- Constant `_RESIDUAL_SCOPE_DEFAULT_LIMIT` (line 47)
- Constant `_RESIDUAL_SCOPE_BUDGET_DEFAULT` (line 48)
- Constant `_RESIDUAL_SCOPE_DENSE_FALLBACK_LIMIT` (line 49)

### covertreex/api/__init__.py
Public ergonomic façade for covertreex.
**Imports**
- Internal: `from covertreex.metrics.residual.policy import ResidualPolicy`
- Internal: `from .pcct import PCCT`
- Internal: `from .runtime import Residual, Runtime`
**Functions**
- None
**Classes**
- None

### covertreex/api/pcct.py
**Imports**
- Internal: `from covertreex.algo.batch import BatchInsertPlan, batch_insert`
- Internal: `from covertreex.algo.batch_delete import BatchDeletePlan, batch_delete`
- Internal: `from covertreex.api.runtime import Runtime`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.queries.knn import knn`
**Functions**
- `_ensure_points(backend: TreeBackend, value: Any) -> Any` (line 13)
- `_ensure_indices(backend: TreeBackend, value: Any) -> Any` (line 26)
- `_convert_tree(tree: PCCTree, backend: TreeBackend) -> PCCTree` (line 31)
**Classes**
- `PCCT` (line 45)
  - `fit(self, points: Any, *, apply_batch_order: bool=True, mis_seed: int | None=None, return_plan: bool=False) -> PCCTree | Tuple[PCCTree, BatchInsertPlan]` (line 51)
  - `insert(self, batch_points: Any, *, mis_seed: int | None=None, apply_batch_order: bool | None=None, return_plan: bool=False) -> PCCTree | Tuple[PCCTree, BatchInsertPlan]` (line 74)
  - `delete(self, indices: Any, *, return_plan: bool=False) -> PCCTree | Tuple[PCCTree, BatchDeletePlan]` (line 97)
  - `knn(self, query_points: Any, *, k: int, return_distances: bool=False) -> Any` (line 116)
  - `nearest(self, query_points: Any, *, return_distances: bool=False) -> Any` (line 137)
  - `_require_tree(self) -> PCCTree` (line 140)

### covertreex/api/runtime.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.metrics.residual.policy import ResidualPolicy`
- Internal: `from covertreex.runtime.model import RuntimeModel`
**Functions**
- `_maybe_tuple(value: Iterable[str] | Tuple[str, ...] | None) -> Tuple[str, ...] | None` (line 11)
- `_apply_if_present(target: Dict[str, Any], key: str, value: Any) -> None` (line 19)
- `_active_runtime_config() -> cx_config.RuntimeConfig` (line 24)
- `_policy_to_overrides(policy: ResidualPolicy) -> Dict[str, Any]` (line 31)
- `_resolve_field_path(field: str) -> Tuple[str, ...]` (line 103)
- `_set_nested(payload: Dict[str, Any], path: Sequence[str], value: Any) -> None` (line 116)
**Classes**
- `Residual` (line 130)
  - `as_overrides(self, base_policy: ResidualPolicy | None=None) -> Dict[str, Any]` (line 156)
  - `from_config(cls, config: cx_config.RuntimeConfig) -> 'Residual'` (line 161)
  - `from_policy(cls, policy: ResidualPolicy) -> 'Residual'` (line 189)
  - `to_policy(self, base: ResidualPolicy | None=None) -> ResidualPolicy` (line 215)
- `Runtime` (line 247)
  - `to_model(self, base: RuntimeModel | None=None) -> RuntimeModel` (line 289)
  - `to_config(self, base: cx_config.RuntimeConfig | None=None) -> cx_config.RuntimeConfig` (line 313)
  - `activate(self) -> cx_config.RuntimeContext` (line 322)
  - `describe(self) -> Dict[str, Any]` (line 328)
  - `with_updates(self, **kwargs: Any) -> 'Runtime'` (line 350)
  - `from_profile(cls, name: str, *, overrides: Sequence[str] | Mapping[str, Any] | None=None) -> 'Runtime'` (line 354)
  - `from_active(cls) -> 'Runtime'` (line 376)
  - `from_config(cls, config: cx_config.RuntimeConfig) -> 'Runtime'` (line 383)
  - `_apply_field(self, payload: Dict[str, Any], field: str, value: Any) -> None` (line 285)
**Other**
- Constant `_ATTR_TO_FIELD` (line 57)
- Constant `_FIELD_PATH_OVERRIDES` (line 93)

### covertreex/baseline.py
**Imports**
- Internal: None
**Functions**
- `has_external_cover_tree() -> bool` (line 466)
- `has_gpboost_cover_tree() -> bool` (line 570)
- `_gpboost_euclidean_distances(coords: np.ndarray, i: int, cand_idx: np.ndarray) -> np.ndarray` (line 34)
- `_gpboost_distances_funct(coord_ind_i: int, coords_ind_j: Sequence[int], coords: np.ndarray) -> np.ndarray` (line 49)
- `_gpboost_cover_tree_knn(coords_mat: np.ndarray, *, start: int=0, max_radius: float) -> Tuple[Dict[int, List[int]], int]` (line 60)
- `_gpboost_find_knn(*, query_index: int, k: int, levels: int, coords: np.ndarray, cover_tree: Dict[int, List[int]]) -> Tuple[List[int], List[float]]` (line 129)
- `_gpboost_cover_tree_knn(*_: Any, **__: Any) -> Tuple[Dict[int, List[int]], int]` (line 222)
- `_gpboost_find_knn(*_: Any, **__: Any) -> Tuple[List[int], List[float]]` (line 226)
- `_log2_ceil(value: float) -> int` (line 230)
- `_euclidean(a: np.ndarray, b: np.ndarray) -> float` (line 236)
- `_pairwise_distances(points: np.ndarray, query: np.ndarray) -> np.ndarray` (line 240)
- `_sort_vectors_decreasing_inplace(a: List[float], b: List[int]) -> None` (line 245)
**Classes**
- `BaselineNode` (line 256)
  - None
- `BaselineCoverTree` (line 264)
  - `from_points(cls, points: Sequence[Sequence[float]]) -> 'BaselineCoverTree'` (line 272)
  - `insert_point(self, point_index: int) -> None` (line 296)
  - `nearest(self, query: Sequence[float]) -> Tuple[int, float]` (line 343)
  - `knn(self, queries: Sequence[Sequence[float]] | Sequence[float], k: int, *, return_distances: bool=False) -> Tuple[np.ndarray, np.ndarray] | np.ndarray` (line 353)
  - `_children_at_level(self, level: int) -> List[int]` (line 290)
- `ExternalCoverTreeBaseline` (line 397)
  - `from_points(cls, points: Sequence[Sequence[float]], *, leafsize: int=10, base: int=2) -> 'ExternalCoverTreeBaseline'` (line 407)
  - `num_points(self) -> int` (line 427)
  - `nearest(self, query: Sequence[float]) -> Tuple[int, float]` (line 430)
  - `knn(self, queries: Sequence[Sequence[float]] | Sequence[float], *, k: int, return_distances: bool=False) -> Tuple[np.ndarray, np.ndarray] | np.ndarray` (line 434)
  - `__init__(self, tree: '_ExternalCoverTree', points: np.ndarray) -> None` (line 400)
- `GPBoostCoverTreeBaseline` (line 470)
  - `from_points(cls, points: Sequence[Sequence[float]]) -> 'GPBoostCoverTreeBaseline'` (line 487)
  - `num_points(self) -> int` (line 507)
  - `nearest(self, query: Sequence[float]) -> Tuple[int, float]` (line 510)
  - `knn(self, queries: Sequence[Sequence[float]] | Sequence[float], *, k: int, return_distances: bool=False) -> Tuple[np.ndarray, np.ndarray] | np.ndarray` (line 514)
  - `__init__(self, *, cover_tree: Dict[int, List[int]], levels: int, points: np.ndarray) -> None` (line 473)
**Other**
- Constant `_HAS_EXTERNAL_COVERTREE` (line 17)
- Constant `_HAS_NUMBA` (line 25)
- Constant `Q` (line 138)
- Constant `Q` (line 192)

### covertreex/config.py
Backwards-compatible shim for the runtime configuration helpers.
**Imports**
- Internal: `from covertreex.runtime.config import *`
- Internal: `from covertreex.runtime import config`
**Functions**
- None
**Classes**
- None

### covertreex/core/__init__.py
Core data structures and persistence primitives for the PCCT.
**Imports**
- Internal: `from .metrics import Metric, MetricRegistry, available_metrics, configure_residual_metric, get_metric, reset_residual_metric`
- Internal: `from .persistence import DEFAULT_JOURNAL_POOL, JournalScratchPool, PersistenceJournal, SliceUpdate, apply_persistence_journal, build_persistence_journal, clone_array_segment, clone_tree_with_updates`
- Internal: `from .tree import PCCTree, TreeBackend, TreeLogStats, get_runtime_backend`
**Functions**
- None
**Classes**
- None

### covertreex/core/_persistence_numba.py
**Imports**
- Internal: None
**Functions**
- `apply_journal_cow(parents_in: np.ndarray, levels_in: np.ndarray, children_in: np.ndarray, next_in: np.ndarray, inserted_parents: np.ndarray, inserted_levels: np.ndarray, head_parents: np.ndarray, head_values: np.ndarray, next_nodes: np.ndarray, next_values: np.ndarray, parents_out: np.ndarray, levels_out: np.ndarray, children_out: np.ndarray, next_out: np.ndarray, base_length: int) -> None` (line 76)
- `_require_numba() -> None` (line 16)
- `_apply_journal_cow_impl(parents_in: np.ndarray, levels_in: np.ndarray, children_in: np.ndarray, next_in: np.ndarray, inserted_parents: np.ndarray, inserted_levels: np.ndarray, head_parents: np.ndarray, head_values: np.ndarray, next_nodes: np.ndarray, next_values: np.ndarray, parents_out: np.ndarray, levels_out: np.ndarray, children_out: np.ndarray, next_out: np.ndarray, base_length: int) -> None` (line 28)
**Classes**
- None
**Other**
- Constant `NUMBA_PERSISTENCE_AVAILABLE` (line 8)
- Constant `I32` (line 13)

### covertreex/core/metrics.py
**Imports**
- Internal: `from covertreex.logging import get_logger`
- Internal: `from covertreex import config`
**Functions**
- `get_metric(name: str | None=None) -> Metric` (line 171)
- `configure_residual_metric(*, pairwise: PairwiseKernel, pointwise: PointwiseKernel | None=None) -> None` (line 179)
- `reset_residual_metric() -> None` (line 191)
- `available_metrics() -> Tuple[str, ...]` (line 205)
- `describe_registered_metrics() -> Tuple[dict[str, str], ...]` (line 209)
- `_resolve_runtime_config() -> cx_config.RuntimeConfig` (line 38)
- `_ensure_2d(backend: 'TreeBackend', array: ArrayLike) -> ArrayLike` (line 78)
- `_euclidean_pairwise(backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 85)
- `_euclidean_pointwise(backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 97)
- `_load_runtime_registry() -> MetricRegistry` (line 110)
- `_residual_pairwise(backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 126)
- `_residual_pointwise(backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 135)
- `_load_metric_plugins() -> None` (line 216)
**Classes**
- `PairwiseKernel` (line 13) (bases: Protocol)
  - `__call__(self, backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 14)
- `PointwiseKernel` (line 18) (bases: Protocol)
  - `__call__(self, backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 19)
- `Metric` (line 24)
  - `pairwise(self, backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 31)
  - `pointwise(self, backend: 'TreeBackend', lhs: ArrayLike, rhs: ArrayLike) -> ArrayLike` (line 34)
- `MetricRegistry` (line 45)
  - `register(self, metric: Metric, *, overwrite: bool=False) -> None` (line 51)
  - `get(self, name: str) -> Metric` (line 57)
  - `names(self) -> Tuple[str, ...]` (line 63)
  - `unregister(self, name: str) -> None` (line 66)
  - `describe(self) -> Tuple[Tuple[str, str], ...]` (line 70)
  - `__init__(self) -> None` (line 48)
**Other**
- Constant `_RESIDUAL_PAIRWISE_IMPL` (line 122)
- Constant `_RESIDUAL_POINTWISE_IMPL` (line 123)
- Constant `_REGISTRY` (line 161)
- Constant `_RESIDUAL_PAIRWISE_IMPL` (line 187)
- Constant `_RESIDUAL_POINTWISE_IMPL` (line 188)
- Constant `_RESIDUAL_PAIRWISE_IMPL` (line 195)
- Constant `_RESIDUAL_POINTWISE_IMPL` (line 196)

### covertreex/core/persistence.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core._persistence_numba import NUMBA_PERSISTENCE_AVAILABLE, apply_journal_cow`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
**Functions**
- `clone_array_segment(backend: TreeBackend, source: Any, updates: Iterable[SliceUpdate], *, dtype: Any) -> Any` (line 49)
- `clone_tree_with_updates(tree: PCCTree, *, points_updates: Iterable[SliceUpdate]=(), top_level_updates: Iterable[SliceUpdate]=(), parent_updates: Iterable[SliceUpdate]=(), child_updates: Iterable[SliceUpdate]=(), level_offset_updates: Iterable[SliceUpdate]=(), si_cache_updates: Iterable[SliceUpdate]=(), next_cache_updates: Iterable[SliceUpdate]=()) -> PCCTree` (line 82)
- `build_persistence_journal(tree: PCCTree, *, backend: TreeBackend | None=None, inserted_points: np.ndarray, inserted_levels: np.ndarray, inserted_parents: np.ndarray, inserted_si: np.ndarray, pool: JournalScratchPool | None=None) -> PersistenceJournal` (line 293)
- `apply_persistence_journal(tree: PCCTree, journal: PersistenceJournal, *, backend: TreeBackend | None=None, context: cx_config.RuntimeContext | None=None) -> PCCTree` (line 345)
- `_ensure_array(backend: TreeBackend, values: Any, *, dtype: Any) -> Any` (line 24)
- `_normalise_index(index: Tuple[int, ...] | Tuple[slice, ...] | int | slice) -> Tuple[Any, ...]` (line 28)
- `_required_length_along_axis(index: Tuple[Any, ...], current: int) -> int` (line 34)
- `_pool_next_capacity(current: int, required: int) -> int` (line 124)
- `_compute_level_offsets_incremental(current_offsets: np.ndarray, inserted_levels: np.ndarray) -> np.ndarray` (line 197)
- `_build_head_and_sibling_updates(inserted_parents: np.ndarray, base_children: np.ndarray, *, base_length: int, pool: JournalScratchPool) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]` (line 243)
- `_apply_journal_numba(tree: PCCTree, journal: PersistenceJournal, *, backend: TreeBackend) -> PCCTree` (line 364)
- `_apply_journal_numpy(tree: PCCTree, journal: PersistenceJournal, *, backend: TreeBackend) -> PCCTree` (line 424)
- `_apply_journal_clone(tree: PCCTree, journal: PersistenceJournal, *, backend: TreeBackend) -> PCCTree` (line 485)
**Classes**
- `SliceUpdate` (line 17)
  - None
- `JournalScratchPool` (line 133)
  - `head_parents(self, required: int) -> np.ndarray` (line 154)
  - `head_values(self, required: int) -> np.ndarray` (line 157)
  - `next_nodes(self, required: int) -> np.ndarray` (line 160)
  - `next_values(self, required: int) -> np.ndarray` (line 163)
  - `children(self, required: int) -> np.ndarray` (line 166)
  - `_request(self, name: str, required: int) -> np.ndarray` (line 143)
- `PersistenceJournal` (line 174)
  - `inserted_count(self) -> int` (line 189)
  - `total_length(self) -> int` (line 193)
**Other**
- Constant `DEFAULT_JOURNAL_POOL` (line 170)

### covertreex/core/tree.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.logging import get_logger`
**Functions**
- `get_runtime_backend() -> TreeBackend` (line 123)
- `compute_level_offsets(backend: TreeBackend, top_levels: ArrayLike) -> ArrayLike` (line 129)
- `_device_put_default(value: ArrayLike) -> ArrayLike` (line 20)
- `_context_backend() -> TreeBackend` (line 117)
**Classes**
- `TreeBackend` (line 27)
  - `jax(cls, *, precision: str='float64') -> 'TreeBackend'` (line 45)
  - `numpy(cls, *, precision: str='float64') -> 'TreeBackend'` (line 64)
  - `gpu(cls, *, precision: str='float32') -> 'TreeBackend'` (line 81)
  - `array(self, value: ArrayLike, *, dtype: Any | None=None) -> ArrayLike` (line 88)
  - `zeros(self, shape: Iterable[int], *, dtype: Any | None=None) -> ArrayLike` (line 94)
  - `ones(self, shape: Iterable[int], *, dtype: Any | None=None) -> ArrayLike` (line 97)
  - `empty(self, shape: Iterable[int], *, dtype: Any | None=None) -> ArrayLike` (line 100)
  - `to_numpy(self, value: ArrayLike) -> Any` (line 103)
- `TreeLogStats` (line 147)
  - `as_dict(self) -> Dict[str, int]` (line 155)
- `PCCTree` (line 165)
  - `num_points(self) -> int` (line 221)
  - `num_levels(self) -> int` (line 225)
  - `dimension(self) -> int` (line 229)
  - `materialise(self) -> Dict[str, Any]` (line 234)
  - `replace(self, *, points: ArrayLike | None=None, top_levels: ArrayLike | None=None, parents: ArrayLike | None=None, children: ArrayLike | None=None, level_offsets: ArrayLike | None=None, si_cache: ArrayLike | None=None, next_cache: ArrayLike | None=None, stats: TreeLogStats | None=None, backend: TreeBackend | None=None) -> 'PCCTree'` (line 250)
  - `to_backend(self, backend: TreeBackend) -> 'PCCTree'` (line 277)
  - `empty(cls, *, dimension: int, backend: TreeBackend | None=None) -> 'PCCTree'` (line 292)
  - `is_empty(self) -> bool` (line 310)
  - `validate(self) -> None` (line 314)
  - `__post_init__(self) -> None` (line 185)
  - `_validate_shapes(self) -> None` (line 194)
**Other**
- Constant `LOGGER` (line 114)

### covertreex/diagnostics.py
Compatibility shim for :mod:`covertreex.runtime.diagnostics`.
**Imports**
- Internal: `from covertreex.runtime.diagnostics import *`
- Internal: `from covertreex.runtime import diagnostics`
**Functions**
- None
**Classes**
- None

### covertreex/exceptions.py
**Imports**
- Internal: None
**Functions**
- None
**Classes**
- `ResidualPairwiseCacheError` (line 4) (bases: RuntimeError)
  - None

### covertreex/logging.py
Compatibility shim for :mod:`covertreex.runtime.logging`.
**Imports**
- Internal: `from covertreex.runtime.logging import *`
- Internal: `from covertreex.runtime import logging`
**Functions**
- None
**Classes**
- None

### covertreex/metrics/__init__.py
Metric-specific helpers for Covertreex.
**Imports**
- Internal: `from .residual import ResidualCorrHostData, ResidualGateLookup, ResidualGateProfile, ResidualGateTelemetry, build_residual_backend, compute_residual_distance_single, compute_residual_distances, compute_residual_distances_with_radius, compute_residual_distances_from_kernel, compute_residual_distances_with_kernel, compute_residual_lower_bounds_from_kernel, configure_residual_correlation, decode_indices, get_residual_backend, set_residual_backend`
**Functions**
- None
**Classes**
- None

### covertreex/metrics/_residual_numba.py
**Imports**
- Internal: None
**Functions**
- `compute_distance_chunk(v_query: np.ndarray, v_chunk: np.ndarray, kernel_chunk: np.ndarray, p_i: float, p_chunk: np.ndarray, norm_query: float, norm_chunk: np.ndarray, radius: float, eps: float) -> Tuple[np.ndarray, np.ndarray]` (line 208)
- `gate1_whitened_mask(v_query: np.ndarray, v_chunk: np.ndarray, threshold: float) -> np.ndarray` (line 283)
- `distance_block_no_gate(v_matrix: np.ndarray, p_diag: np.ndarray, v_norm_sq: np.ndarray, query_indices: np.ndarray, chunk_indices: np.ndarray, kernel_block: np.ndarray, radii: np.ndarray, eps: float) -> Tuple[np.ndarray, np.ndarray]` (line 307)
- `_distance_chunk(v_query: np.ndarray, v_chunk: np.ndarray, kernel_chunk: np.ndarray, p_i: float, p_chunk: np.ndarray, norm_query: float, norm_chunk: np.ndarray, radius: float, eps: float) -> Tuple[np.ndarray, np.ndarray]` (line 21)
- `_gate1_whitened_chunk(v_query: np.ndarray, v_chunk: np.ndarray, threshold_sq: float) -> np.ndarray` (line 95)
- `_distance_block_no_gate(v_matrix: np.ndarray, p_diag: np.ndarray, v_norm_sq: np.ndarray, query_indices: np.ndarray, chunk_indices: np.ndarray, kernel_block: np.ndarray, radii: np.ndarray, eps: float) -> Tuple[np.ndarray, np.ndarray]` (line 125)
**Classes**
- None
**Other**
- Constant `NUMBA_RESIDUAL_AVAILABLE` (line 11)

### covertreex/metrics/residual/__init__.py
**Imports**
- Internal: `from . import core`
- Internal: `from . import scope_caps`
- Internal: `from .core import *`
- Internal: `from .policy import RESIDUAL_EPS, ResidualGateLookup, ResidualGateProfile, ResidualGateTelemetry, ResidualPolicy, get_residual_policy`
- Internal: `from .scope_caps import *`
- Internal: `from .host_backend import build_residual_backend`
**Functions**
- None
**Classes**
- None

### covertreex/metrics/residual/_gate_profile_numba.py
**Imports**
- Internal: None
**Functions**
- `update_quantile_reservoir(bin_indices: np.ndarray, values: np.ndarray, samples: np.ndarray, sample_counts: np.ndarray, total_counts: np.ndarray) -> None` (line 48)
- `_update_quantile_reservoir_impl(bin_indices: np.ndarray, values: np.ndarray, samples: np.ndarray, sample_counts: np.ndarray, total_counts: np.ndarray) -> None` (line 17)
**Classes**
- None
**Other**
- Constant `_NUMBA_AVAILABLE` (line 8)

### covertreex/metrics/residual/core.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from .._residual_numba import compute_distance_chunk, distance_block_no_gate`
- Internal: `from .policy import RESIDUAL_EPS, ResidualGateLookup, ResidualGateProfile, ResidualGateTelemetry, ResidualPolicy, get_residual_policy`
**Functions**
- `set_residual_backend(backend: ResidualCorrHostData | None) -> None` (line 257)
- `get_residual_backend() -> ResidualCorrHostData` (line 264)
- `decode_indices(host_backend: ResidualCorrHostData, payload: ArrayLike) -> np.ndarray` (line 280)
- `compute_whitened_block(backend: ResidualCorrHostData, query_indices: np.ndarray, chunk_indices: np.ndarray, *, workspace: ResidualWorkspace | None=None) -> np.ndarray` (line 387)
- `compute_residual_distances_with_kernel(backend: ResidualCorrHostData, lhs_indices: np.ndarray, rhs_indices: np.ndarray, *, chunk_size: Optional[int]=None) -> tuple[np.ndarray, np.ndarray]` (line 502)
- `compute_residual_distances(backend: ResidualCorrHostData, lhs_indices: np.ndarray, rhs_indices: np.ndarray, *, chunk_size: Optional[int]=None) -> np.ndarray` (line 533)
- `compute_residual_distances_from_kernel(backend: ResidualCorrHostData, lhs_indices: np.ndarray, rhs_indices: np.ndarray, kernel_block: np.ndarray) -> np.ndarray` (line 551)
- `compute_residual_lower_bounds_from_kernel(backend: ResidualCorrHostData, lhs_indices: np.ndarray, rhs_indices: np.ndarray, kernel_block: np.ndarray) -> np.ndarray` (line 562)
- `compute_residual_pairwise_matrix(host_backend: ResidualCorrHostData, batch_indices: np.ndarray, *, telemetry: ResidualDistanceTelemetry | None=None) -> np.ndarray` (line 582)
- `compute_residual_distances_with_radius(backend: ResidualCorrHostData, query_index: int, chunk_indices: np.ndarray, kernel_row: np.ndarray | None, radius: float, *, workspace: ResidualWorkspace | None=None, telemetry: ResidualDistanceTelemetry | None=None, force_whitened: bool=False) -> Tuple[np.ndarray, np.ndarray]` (line 611)
- `compute_residual_distances_block_no_gate(backend: ResidualCorrHostData, query_indices: np.ndarray, chunk_indices: np.ndarray, kernel_block: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]` (line 833)
- `compute_residual_distance_single(backend: ResidualCorrHostData, lhs_index: int, rhs_index: int) -> float` (line 871)
- `configure_residual_correlation(backend: ResidualCorrHostData, *, policy: ResidualPolicy | None=None, runtime: cx_config.RuntimeConfig | None=None, context: cx_config.RuntimeContext | None=None) -> None` (line 885)
- `_default_point_decoder(values: ArrayLike) -> np.ndarray` (line 37)
- `_finalize_gate_profile(backend: ResidualCorrHostData | None) -> None` (line 249)
- `_normalise_indices(indices: np.ndarray, total: int) -> np.ndarray` (line 274)
- `_compute_distances_from_kernel_block(backend: ResidualCorrHostData, lhs_indices: np.ndarray, rhs_indices: np.ndarray, kernel_block: np.ndarray) -> np.ndarray` (line 290)
- `_compute_gate1_whitened(matrix: np.ndarray, *, regularisation: float=1e-06) -> tuple[np.ndarray, np.ndarray]` (line 323)
- `_ensure_whitened_cache(backend: ResidualCorrHostData) -> tuple[np.ndarray, np.ndarray]` (line 362)
- `_compute_gate1_distances(backend: ResidualCorrHostData, query_index: int, candidate_idx: np.ndarray) -> np.ndarray | None` (line 372)
- `_resolve_gate1_config(backend: ResidualCorrHostData, *, policy: ResidualPolicy) -> tuple[bool, float, float, float, bool, float, float, float, float]` (line 422)
- `_audit_gate1_pruned(*, backend: ResidualCorrHostData, query_index: int, candidate_idx: np.ndarray, kernel_vals: np.ndarray, keep_mask: np.ndarray, radius: float, whitened_distances: np.ndarray | None) -> None` (line 457)
**Classes**
- `KernelProvider` (line 27) (bases: Protocol)
  - `__call__(self, row_indices: np.ndarray, col_indices: np.ndarray) -> np.ndarray` (line 28)
- `PointDecoder` (line 32) (bases: Protocol)
  - `__call__(self, values: ArrayLike) -> np.ndarray` (line 33)
- `ResidualCorrHostData` (line 53)
  - `num_points(self) -> int` (line 136)
  - `rank(self) -> int` (line 140)
  - `v_matrix_view(self, dtype: np.dtype | type[np.floating]) -> np.ndarray` (line 143)
  - `p_diag_view(self, dtype: np.dtype | type[np.floating]) -> np.ndarray` (line 155)
  - `kernel_diag_view(self, dtype: np.dtype | type[np.floating]) -> np.ndarray` (line 167)
  - `__post_init__(self) -> None` (line 109)
- `ResidualWorkspace` (line 181)
  - `ensure_capacity(self, rows: int, cols: int) -> None` (line 193)
  - `gram_view(self, rows: int, cols: int) -> np.ndarray` (line 200)
  - `dist2_view(self, rows: int, cols: int) -> np.ndarray` (line 204)
  - `mask_view(self, rows: int, cols: int) -> np.ndarray` (line 208)
  - `__post_init__(self) -> None` (line 190)
  - `_resize(self, rows: int, cols: int) -> None` (line 212)
- `ResidualDistanceTelemetry` (line 221)
  - `record_whitened(self, rows: int, cols: int, seconds: float) -> None` (line 231)
  - `record_kernel(self, rows: int, cols: int, seconds: float) -> None` (line 238)
**Other**
- Constant `_EPS` (line 24)
- Constant `_ACTIVE_BACKEND` (line 246)
- Constant `_ACTIVE_BACKEND` (line 261)

### covertreex/metrics/residual/host_backend.py
**Imports**
- Internal: `from .core import ResidualCorrHostData`
**Functions**
- `build_residual_backend(points: np.ndarray, *, seed: int, inducing_count: int, variance: float, lengthscale: float, chunk_size: int=512, rng: Generator | None=None) -> ResidualCorrHostData` (line 90)
- `_rbf_kernel(x: np.ndarray, y: np.ndarray, *, variance: float, lengthscale: float) -> np.ndarray` (line 14)
- `_build_sgemm_rbf_provider(points: np.ndarray, *, variance: float, lengthscale: float) -> Tuple[np.ndarray, np.ndarray, Callable[[np.ndarray, np.ndarray], np.ndarray]]` (line 28)
- `_point_decoder_factory(points: np.ndarray) -> Callable[[ArrayLike], np.ndarray]` (line 60)
**Classes**
- None

### covertreex/metrics/residual/policy.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from ._gate_profile_numba import update_quantile_reservoir`
**Functions**
- `get_residual_policy(runtime: cx_config.RuntimeConfig | None=None) -> ResidualPolicy` (line 388)
- `_normalise_percentiles(values: Sequence[float] | None) -> np.ndarray` (line 19)
- `_format_percentile(value: float) -> str` (line 34)
**Classes**
- `ResidualGateTelemetry` (line 42)
  - `snapshot(self) -> Tuple[int, int, int, float]` (line 48)
  - `delta(self, snapshot: Tuple[int, int, int, float]) -> 'ResidualGateTelemetry'` (line 51)
- `ResidualGateProfile` (line 62)
  - `create(cls, *, bins: int, radius_max: float, path: str | Path | None, radius_eps: float=RESIDUAL_EPS, quantile_percentiles: Sequence[float] | None=None, quantile_sample_cap: int=_DEFAULT_PROFILE_SAMPLE_CAP) -> 'ResidualGateProfile'` (line 81)
  - `record_chunk(self, *, residual_distances: np.ndarray, whitened_distances: np.ndarray, inclusion_mask: np.ndarray) -> None` (line 145)
  - `record_false_negatives(self, *, residual_distances: np.ndarray, whitened_distances: np.ndarray, inclusion_mask: np.ndarray) -> None` (line 168)
  - `annotate_metadata(self, **metadata: Any) -> None` (line 182)
  - `to_dict(self) -> dict` (line 216)
  - `dump(self, path: str | Path | None=None, *, force: bool=False) -> None` (line 245)
  - `_bin_indices(self, values: np.ndarray) -> np.ndarray` (line 121)
  - `_record_quantiles(self, idx: np.ndarray, whitened: np.ndarray) -> None` (line 125)
  - `_cumulative_whitened(self) -> np.ndarray` (line 189)
  - `_cumulative_ratio(self) -> np.ndarray` (line 192)
  - `_quantile_payload(self) -> Dict[str, Any] | None` (line 195)
- `ResidualGateLookup` (line 259)
  - `from_payload(cls, payload: dict, *, margin: float, keep_pct: float, prune_pct: float) -> 'ResidualGateLookup'` (line 266)
  - `load(cls, path: str | Path, *, margin: float, keep_pct: float, prune_pct: float) -> 'ResidualGateLookup'` (line 311)
  - `thresholds(self, radius: float) -> tuple[float, float]` (line 323)
- `ResidualPolicy` (line 338)
  - `from_runtime(cls, runtime: cx_config.RuntimeConfig) -> 'ResidualPolicy'` (line 362)
**Other**
- Constant `RESIDUAL_EPS` (line 14)
- Constant `_DEFAULT_PROFILE_SAMPLE_CAP` (line 15)
- Constant `_DEFAULT_PROFILE_QUANTILES` (line 16)

### covertreex/metrics/residual/scope_caps.py
**Imports**
- Internal: None
**Functions**
- `get_scope_cap_table(path: str | None) -> ResidualScopeCapTable | None` (line 78)
- `reset_scope_cap_cache() -> None` (line 91)
- `_normalise_cap(value: float | None) -> float | None` (line 15)
- `_coerce_level_list(level_field: int | List[int] | None) -> Iterable[int]` (line 23)
**Classes**
- `ResidualScopeCapTable` (line 32)
  - `from_payload(cls, payload: dict) -> 'ResidualScopeCapTable'` (line 37)
  - `load(cls, path: str | Path) -> 'ResidualScopeCapTable'` (line 62)
  - `lookup(self, levels: np.ndarray) -> np.ndarray` (line 67)
**Other**
- Constant `_SCOPE_CAP_CACHE` (line 11)
- Constant `_CACHE_LOCK` (line 12)

### covertreex/plugins/__init__.py
**Imports**
- Internal: `from . import conflict, metrics, traversal`
**Functions**
- None
**Classes**
- None

### covertreex/plugins/_loader.py
**Imports**
- Internal: `from covertreex.logging import get_logger`
**Functions**
- `load_entrypoint_plugins(group: str, handler: Callable[[Any], None]) -> list[str]` (line 22)
- `_select_entry_points(group: str) -> Sequence[Any]` (line 11)
**Classes**
- None
**Other**
- Constant `LOGGER` (line 8)

### covertreex/plugins/conflict.py
**Imports**
- Internal: `from covertreex.algo.conflict.strategies import deregister_conflict_strategy, describe_conflict_strategies, register_conflict_strategy`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from ._loader import load_entrypoint_plugins`
**Functions**
- `load_entrypoints() -> list[str]` (line 48)
- `list_plugins() -> list[dict[str, str]]` (line 57)
- `_iter_specs(payload: Any) -> Iterable[tuple[str, Any, Any, str | None]]` (line 18)
- `_register_payload(payload: Any) -> None` (line 43)
**Classes**
- None
**Other**
- Constant `LOGGER` (line 14)
- Constant `GROUP` (line 15)
- Constant `_LOADED` (line 52)

### covertreex/plugins/metrics.py
**Imports**
- Internal: `from covertreex.core.metrics import Metric, _REGISTRY, describe_registered_metrics`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from ._loader import load_entrypoint_plugins`
**Functions**
- `load_entrypoints() -> list[str]` (line 34)
- `list_metrics() -> list[dict[str, str]]` (line 43)
- `_iter_metrics(payload: Any) -> Iterable[Metric]` (line 14)
- `_register_payload(payload: Any) -> None` (line 29)
**Classes**
- None
**Other**
- Constant `LOGGER` (line 10)
- Constant `GROUP` (line 11)
- Constant `_LOADED` (line 38)

### covertreex/plugins/traversal.py
**Imports**
- Internal: `from covertreex.algo.traverse.strategies.registry import deregister_traversal_strategy, describe_traversal_strategies, register_traversal_strategy`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from ._loader import load_entrypoint_plugins`
**Functions**
- `load_entrypoints() -> list[str]` (line 53)
- `list_plugins() -> list[dict[str, str]]` (line 63)
- `_iter_specs(payload: Any) -> Iterable[tuple[str, Any, Any, str | None]]` (line 18)
- `_register_payload(payload: Any) -> None` (line 43)
**Classes**
- None
**Other**
- Constant `LOGGER` (line 14)
- Constant `GROUP` (line 15)
- Constant `_LOADED` (line 58)

### covertreex/queries/__init__.py
Query algorithms (k-NN, radius search) built on top of the PCCT.
**Imports**
- Internal: `from .knn import knn, nearest_neighbor`
**Functions**
- None
**Classes**
- None

### covertreex/queries/_knn_numba.py
**Imports**
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
**Functions**
- `materialise_tree_view(tree: PCCTree) -> NumbaTreeView` (line 315)
- `knn_numba(view: NumbaTreeView, queries: Iterable[np.ndarray], *, k: int, return_distances: bool) -> Tuple[np.ndarray, np.ndarray] | np.ndarray` (line 370)
- `materialise_tree_view_cached(tree: PCCTree) -> NumbaTreeView` (line 433)
- `_to_numpy(array: Any, backend: TreeBackend, *, dtype: Any) -> np.ndarray` (line 36)
- `_sqdist_row(query: np.ndarray, point: np.ndarray) -> float` (line 46)
- `_insert_partial(indices: np.ndarray, dists: np.ndarray, count: int, idx: int, dist: float) -> None` (line 54)
- `_insert_full(indices: np.ndarray, dists: np.ndarray, idx: int, dist: float) -> None` (line 69)
- `_knn_single(query: np.ndarray, points: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]` (line 84)
- `_cover_tree_knn_single(query: np.ndarray, points: np.ndarray, si_cache: np.ndarray, children: np.ndarray, next_cache: np.ndarray, children_offsets: np.ndarray, children_list: np.ndarray, roots: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]` (line 105)
- `_knn_batch_cover(queries: np.ndarray, points: np.ndarray, si_cache: np.ndarray, children: np.ndarray, next_cache: np.ndarray, children_offsets: np.ndarray, children_list: np.ndarray, roots: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]` (line 284)
**Classes**
- `NumbaTreeView` (line 23)
  - None
**Other**
- Constant `NUMBA_QUERY_AVAILABLE` (line 13)
- Constant `_EPS` (line 43)
- Constant `_VIEW_CACHE` (line 455)

### covertreex/queries/knn.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend`
- Internal: `from covertreex.diagnostics import log_operation`
- Internal: `from covertreex.logging import get_logger`
- Internal: `from covertreex.queries._knn_numba import NUMBA_QUERY_AVAILABLE, materialise_tree_view_cached, knn_numba`
**Functions**
- `knn(tree: PCCTree, query_points: Any, *, k: int, return_distances: bool=False, backend: TreeBackend | None=None, context: cx_config.RuntimeContext | None=None) -> Tuple[Any, Any] | Any` (line 165)
- `nearest_neighbor(tree: PCCTree, query_points: Any, *, return_distances: bool=False, backend: TreeBackend | None=None, context: cx_config.RuntimeContext | None=None) -> Tuple[Any, Any] | Any` (line 287)
- `_to_numpy_array(backend: TreeBackend, array: Any, dtype: Any) -> np.ndarray` (line 23)
- `_fallback_bruteforce(query: np.ndarray, points: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray]` (line 68)
- `_single_query_knn(query: np.ndarray, *, points: np.ndarray, si_cache: np.ndarray, child_cache: _ChildChainCache, root_indices: Sequence[int], k: int) -> Tuple[np.ndarray, np.ndarray]` (line 79)
- `_knn_impl(op_log: Any, tree: PCCTree, query_points: Any, *, k: int, return_distances: bool, backend: TreeBackend, context: cx_config.RuntimeContext | None) -> Tuple[Any, Any] | Any` (line 190)
**Classes**
- `_ChildChainCache` (line 29)
  - `get(self, parent: int) -> np.ndarray` (line 40)
  - `__init__(self, children: np.ndarray, next_cache: np.ndarray) -> None` (line 34)
**Other**
- Constant `LOGGER` (line 20)

### covertreex/runtime/__init__.py
Runtime configuration, logging, and diagnostics utilities for covertreex.
**Imports**
- Internal: `from .config import RuntimeConfig, RuntimeContext, current_runtime_context, configure_runtime, describe_runtime, runtime_config, runtime_context, set_runtime_context, reset_runtime_context, reset_runtime_config_cache`
- Internal: `from .logging import get_logger`
- Internal: `from .diagnostics import OperationMetrics`
- Internal: `from .model import DiagnosticsConfig, ResidualConfig, RuntimeModel, SeedPack`
**Functions**
- None
**Classes**
- None

### covertreex/runtime/config.py
**Imports**
- Internal: `from .model import RuntimeModel, SeedPack`
**Functions**
- `current_runtime_context() -> Optional['RuntimeContext']` (line 37)
- `runtime_context() -> RuntimeContext` (line 231)
- `runtime_config() -> RuntimeConfig` (line 243)
- `configure_runtime(config: RuntimeConfig) -> RuntimeContext` (line 249)
- `set_runtime_context(context: RuntimeContext) -> RuntimeContext` (line 258)
- `reset_runtime_config_cache() -> None` (line 266)
- `reset_runtime_context() -> None` (line 270)
- `describe_runtime() -> Dict[str, Any]` (line 276)
- `_stack() -> list['RuntimeContext']` (line 28)
- `_current_context_or_none() -> Optional['RuntimeContext']` (line 32)
- `_replace_context(context: 'RuntimeContext') -> None` (line 43)
- `_apply_jax_runtime_flags(config: RuntimeConfig) -> None` (line 137)
- `_configure_logging(level: str) -> None` (line 155)
**Classes**
- `RuntimeConfig` (line 53)
  - `mis_seed(self) -> int | None` (line 112)
  - `batch_order_seed(self) -> int | None` (line 116)
  - `jax_enable_x64(self) -> bool` (line 120)
  - `primary_platform(self) -> str | None` (line 124)
  - `from_env(cls) -> 'RuntimeConfig'` (line 130)
- `RuntimeContext` (line 167)
  - `activate(self) -> None` (line 176)
  - `get_backend(self) -> 'TreeBackend'` (line 211)
  - `__enter__(self) -> 'RuntimeContext'` (line 185)
  - `__exit__(self, exc_type, exc, _tb) -> None` (line 197)
- `_RuntimeContextStack` (line 19) (bases: threading.local)
  - `__init__(self) -> None` (line 20)
**Other**
- Constant `_LOGGER` (line 15)
- Constant `_JAX_WARNING_EMITTED` (line 16)
- Constant `_CONTEXT_STACK` (line 25)
- Constant `_JAX_WARNING_EMITTED` (line 147)

### covertreex/runtime/diagnostics.py
**Imports**
- Internal: `from covertreex import config`
**Functions**
- `log_operation(logger: logging.Logger, label: str, *, level: int=logging.INFO, runtime: cx_config.RuntimeConfig | None=None, context: cx_config.RuntimeContext | None=None) -> Iterator[OperationMetrics]` (line 270)
- `_now_snapshot(*, with_resources: bool, runtime: cx_config.RuntimeConfig | None) -> _ProcessSnapshot` (line 28)
- `_read_rss_bytes() -> Optional[int]` (line 63)
- `_query_gpu_memory(runtime: cx_config.RuntimeConfig | None) -> tuple[Optional[int], Optional[int]]` (line 79)
- `_mark_gpu_failure() -> None` (line 129)
- `_format_bytes(value: Optional[int]) -> str` (line 134)
- `_format_float(value: float) -> str` (line 145)
- `_diff_optional(end: Optional[float], start: Optional[float], *, scale: float=1.0) -> Optional[float]` (line 149)
- `_max_optional(*values: Optional[int]) -> Optional[int]` (line 155)
- `_resolve_runtime_config(runtime: cx_config.RuntimeConfig | None, context: cx_config.RuntimeContext | None) -> cx_config.RuntimeConfig` (line 162)
- `_stringify(value: object) -> str` (line 257)
**Classes**
- `OperationMetrics` (line 177)
  - `add_metadata(self, **kwargs: object) -> None` (line 208)
  - `__enter__(self) -> 'OperationMetrics'` (line 190)
  - `__exit__(self, exc_type, exc, _tb) -> None` (line 199)
  - `_emit(self) -> None` (line 211)
  - `_compute_metrics(self) -> Dict[str, object]` (line 218)
- `_ProcessSnapshot` (line 17)
  - None
**Other**
- Constant `_GPU_FAILURE` (line 76)
- Constant `_GPU_FAILURE` (line 131)

### covertreex/runtime/logging.py
Project-wide logging utilities that honour `RuntimeConfig`.
**Imports**
- Internal: `from . import config`
**Functions**
- `get_logger(name: Optional[str]=None, *, runtime: cx_config.RuntimeConfig | None=None, context: cx_config.RuntimeContext | None=None) -> logging.Logger` (line 26)
- `_resolve_runtime_config(*, runtime: cx_config.RuntimeConfig | None=None, context: cx_config.RuntimeContext | None=None) -> cx_config.RuntimeConfig | None` (line 11)
**Classes**
- None

### covertreex/runtime/model.py
Typed runtime configuration models and env parsing helpers.
**Imports**
- Internal: None
**Functions**
- `_bool_from_env(value: str | None, *, default: bool) -> bool` (line 65)
- `_parse_devices(raw: str | None) -> Tuple[str, ...]` (line 76)
- `_parse_optional_int(raw: str | None) -> int | None` (line 87)
- `_parse_optional_float(raw: str | None, *, default: float) -> float` (line 96)
- `_parse_scope_budget_schedule(raw: str | None) -> Tuple[int, ...]` (line 105)
- `_normalise_precision(value: str | None) -> str` (line 126)
- `_infer_precision_from_env(env: Mapping[str, str]) -> str` (line 137)
- `_infer_backend(raw: str | None) -> str` (line 147)
- `_parse_conflict_graph_impl(value: str | None) -> str` (line 156)
- `_parse_batch_order_strategy(value: str | None) -> str` (line 167)
- `_parse_prefix_schedule(value: str | None, *, default: str) -> str` (line 178)
- `_device_label(device: Any) -> str` (line 189)
- `_resolve_jax_devices(requested: Sequence[str]) -> Tuple[str, ...]` (line 194)
- `_derive_seed_from_global(global_seed: int, channel: str) -> int` (line 220)
**Classes**
- `SeedPack` (line 226) (bases: BaseModel)
  - `resolved(self, channel: str, *, fallback: int=0) -> int` (line 236)
- `DiagnosticsConfig` (line 247) (bases: BaseModel)
  - `model_post_init(self, __context: Any) -> None` (line 255)
- `ResidualConfig` (line 259) (bases: BaseModel)
  - None
- `RuntimeModel` (line 296) (bases: BaseModel)
  - `mis_seed(self) -> int | None` (line 329)
  - `batch_order_seed(self) -> int | None` (line 333)
  - `enable_diagnostics(self) -> bool` (line 337)
  - `log_level(self) -> str` (line 341)
  - `residual_gate1_enabled(self) -> bool` (line 345)
  - `residual_force_whitened(self) -> bool` (line 349)
  - `residual_scope_member_limit(self) -> int | None` (line 353)
  - `residual_stream_tile(self) -> int | None` (line 357)
  - `residual_scope_bitset(self) -> bool` (line 361)
  - `residual_masked_scope_append(self) -> bool` (line 365)
  - `residual_dynamic_query_block(self) -> bool` (line 369)
  - `residual_dense_scope_streamer(self) -> bool` (line 373)
  - `residual_level_cache_batching(self) -> bool` (line 377)
  - `to_runtime_config(self) -> 'RuntimeConfig'` (line 380)
  - `from_legacy_config(cls, legacy: 'RuntimeConfig') -> 'RuntimeModel'` (line 446)
  - `from_env(cls, env: Mapping[str, str] | None=None) -> 'RuntimeModel'` (line 521)
**Other**
- Constant `_LOGGER` (line 18)
- Constant `_FALLBACK_CPU_DEVICE` (line 19)
- Constant `_SUPPORTED_BACKENDS` (line 21)
- Constant `_SUPPORTED_PRECISION` (line 22)
- Constant `_CONFLICT_GRAPH_IMPLS` (line 23)
- Constant `_BATCH_ORDER_STRATEGIES` (line 24)
- Constant `_PREFIX_SCHEDULES` (line 25)
- Constant `_DEFAULT_SCOPE_CHUNK_TARGET` (line 26)
- Constant `_DEFAULT_SCOPE_CHUNK_MAX_SEGMENTS` (line 27)
- Constant `_DEFAULT_SCOPE_CHUNK_PAIR_MERGE` (line 28)
- Constant `_DEFAULT_SCOPE_CONFLICT_BUFFER_REUSE` (line 29)
- Constant `_DEFAULT_CONFLICT_DEGREE_CAP` (line 30)
- Constant `_DEFAULT_SCOPE_BUDGET_SCHEDULE` (line 31)
- Constant `_DEFAULT_RESIDUAL_SCOPE_BUDGET_SCHEDULE` (line 32)
- Constant `_DEFAULT_RESIDUAL_STREAM_TILE` (line 33)
- Constant `_DEFAULT_RESIDUAL_DENSE_SCOPE_STREAMER` (line 34)
- Constant `_DEFAULT_SCOPE_BUDGET_UP_THRESH` (line 35)
- Constant `_DEFAULT_SCOPE_BUDGET_DOWN_THRESH` (line 36)
- Constant `_DEFAULT_BATCH_ORDER_STRATEGY` (line 37)
- Constant `_DEFAULT_PREFIX_SCHEDULE` (line 38)
- Constant `_DEFAULT_PREFIX_DENSITY_LOW` (line 39)
- Constant `_DEFAULT_PREFIX_DENSITY_HIGH` (line 40)
- Constant `_DEFAULT_PREFIX_GROWTH_SMALL` (line 41)
- Constant `_DEFAULT_PREFIX_GROWTH_MID` (line 42)
- Constant `_DEFAULT_PREFIX_GROWTH_LARGE` (line 43)
- Constant `_DEFAULT_RESIDUAL_GATE1_ALPHA` (line 44)
- Constant `_DEFAULT_RESIDUAL_GATE1_MARGIN` (line 45)
- Constant `_DEFAULT_RESIDUAL_GATE1_EPS` (line 46)
- Constant `_DEFAULT_RESIDUAL_GATE1_RADIUS_CAP` (line 47)
- Constant `_DEFAULT_RESIDUAL_RADIUS_FLOOR` (line 48)
- Constant `_DEFAULT_RESIDUAL_GATE1_PROFILE_BINS` (line 49)
- Constant `_DEFAULT_RESIDUAL_GATE1_LOOKUP_MARGIN` (line 50)
- Constant `_DEFAULT_RESIDUAL_GATE1_BAND_EPS` (line 51)
- Constant `_DEFAULT_RESIDUAL_GATE1_KEEP_PCT` (line 52)
- Constant `_DEFAULT_RESIDUAL_GATE1_PRUNE_PCT` (line 53)
- Constant `_DEFAULT_RESIDUAL_SCOPE_CAP_DEFAULT` (line 54)
- Constant `_DEFAULT_RESIDUAL_PREFILTER_MARGIN` (line 55)
- Constant `_DEFAULT_RESIDUAL_PREFILTER_RADIUS_CAP` (line 56)
- Constant `_DEFAULT_RESIDUAL_PREFILTER_LOOKUP` (line 57)
- Constant `_DEFAULT_RESIDUAL_PREFILTER_AUDIT` (line 60)
- Constant `_DEFAULT_RESIDUAL_GRID_WHITEN_SCALE` (line 61)
- Constant `_DEFAULT_RESIDUAL_FORCE_WHITENED` (line 62)

### covertreex/telemetry/__init__.py
**Imports**
- Internal: `from .artifacts import artifact_root, generate_run_id, resolve_artifact_path, timestamped_artifact`
- Internal: `from .logs import BenchmarkLogWriter, ResidualScopeCapRecorder`
- Internal: `from .schemas import BENCHMARK_BATCH_JSON_SCHEMA, BENCHMARK_BATCH_SCHEMA_ID, BENCHMARK_BATCH_SCHEMA_VERSION, BenchmarkBatchRecord, BATCH_OPS_RESULT_SCHEMA, BATCH_OPS_RESULT_SCHEMA_ID, RESIDUAL_SCOPE_CAP_SCHEMA, RESIDUAL_SCOPE_CAP_SCHEMA_ID, RESIDUAL_SCOPE_CAP_SCHEMA_VERSION, RUNTIME_BREAKDOWN_CHUNK_FIELDS, RUNTIME_BREAKDOWN_FIELDNAMES, RUNTIME_BREAKDOWN_SCHEMA, RUNTIME_BREAKDOWN_SCHEMA_ID, runtime_breakdown_fieldnames`
**Functions**
- None
**Classes**
- None

### covertreex/telemetry/artifacts.py
**Imports**
- Internal: None
**Functions**
- `artifact_root(create: bool=True) -> Path` (line 22)
- `resolve_artifact_path(path: PathLike, *, category: Optional[str]=None, create_parents: bool=True) -> Path` (line 32)
- `timestamped_artifact(*, category: Optional[str], prefix: str, suffix: str, create_parents: bool=True) -> Path` (line 55)
- `generate_run_id(*, prefix: str='pcct') -> str` (line 69)
**Classes**
- None
**Other**
- Constant `_ARTIFACT_ENV` (line 11)
- Constant `_DEFAULT_ROOT` (line 12)

### covertreex/telemetry/logs.py
**Imports**
- Internal: `from .schemas import BENCHMARK_BATCH_SCHEMA_ID, BENCHMARK_BATCH_SCHEMA_VERSION, RESIDUAL_SCOPE_CAP_SCHEMA_ID, RESIDUAL_SCOPE_CAP_SCHEMA_VERSION`
**Functions**
- `_read_rss_bytes() -> int | None` (line 28)
- `_ms(value: float) -> float` (line 46)
- `_summarise_metric(record: Dict[str, Any], prefix: str, values: np.ndarray) -> None` (line 50)
- `_metric_summary(values: np.ndarray) -> Dict[str, float]` (line 64)
- `_augment_residual_scope_metrics(record: Dict[str, Any], residual_cache: Any) -> None` (line 80)
- `_hash_payload(payload: Mapping[str, Any]) -> str` (line 121)
**Classes**
- `BenchmarkLogWriter` (line 126)
  - `close(self) -> None` (line 154)
  - `record_batch(self, *, batch_index: int, batch_size: int, plan: Any, extra: Dict[str, Any] | None=None) -> None` (line 158)
  - `__init__(self, path: str, *, run_id: str | None=None, runtime: Mapping[str, Any] | None=None, metadata: Mapping[str, Any] | None=None, run_hash: str | None=None)` (line 127)
  - `__enter__(self) -> 'BenchmarkLogWriter'` (line 281)
  - `__exit__(self, exc_type, exc, tb) -> None` (line 284)
- `ResidualScopeCapRecorder` (line 288)
  - `annotate(self, **metadata: Any) -> None` (line 299)
  - `capture(self, plan: Any) -> None` (line 305)
  - `dump(self) -> None` (line 331)
  - `__init__(self, *, output: str, percentile: float, margin: float, radius_floor: float)` (line 289)

### covertreex/telemetry/schemas.py
**Imports**
- Internal: None
**Functions**
- `runtime_breakdown_fieldnames(*, include_run: bool=True) -> Tuple[str, ...]` (line 204)
**Classes**
- `BenchmarkBatchRecord` (line 44)
  - `from_payload(cls, payload: Mapping[str, Any]) -> 'BenchmarkBatchRecord'` (line 62)
**Other**
- Constant `BENCHMARK_BATCH_SCHEMA_VERSION` (line 6)
- Constant `BENCHMARK_BATCH_SCHEMA_ID` (line 7)
- Constant `BENCHMARK_BATCH_JSON_SCHEMA` (line 8)
- Constant `RESIDUAL_SCOPE_CAP_SCHEMA_VERSION` (line 118)
- Constant `RESIDUAL_SCOPE_CAP_SCHEMA_ID` (line 119)
- Constant `RESIDUAL_SCOPE_CAP_SCHEMA` (line 120)
- Constant `RESIDUAL_GATE_PROFILE_SCHEMA_VERSION` (line 127)
- Constant `RESIDUAL_GATE_PROFILE_SCHEMA_ID` (line 128)
- Constant `RESIDUAL_GATE_PROFILE_SCHEMA` (line 129)
- Constant `RUNTIME_BREAKDOWN_SCHEMA_ID` (line 144)
- Constant `RUNTIME_BREAKDOWN_SCHEMA` (line 145)
- Constant `RUNTIME_BREAKDOWN_CHUNK_FIELDS` (line 168)
- Constant `RUNTIME_BREAKDOWN_FIELDNAMES` (line 183)
- Constant `BATCH_OPS_RESULT_SCHEMA_ID` (line 213)
- Constant `BATCH_OPS_RESULT_SCHEMA` (line 214)

### profiles/__init__.py
**Imports**
- Internal: `from .loader import ProfileDefinition, ProfileMetadata, ProfileError, ProfileFormatError, ProfileNotFoundError, available_profiles, load_profile, load_profile_definition`
- Internal: `from .overrides import OverrideError, apply_overrides_to_model, parse_override_expression, parse_override_expressions`
**Functions**
- None
**Classes**
- None

### profiles/loader.py
**Imports**
- Internal: `from covertreex.runtime.model import RuntimeModel`
**Functions**
- `available_profiles() -> Tuple[str, ...]` (line 61)
- `load_profile_definition(name: str) -> ProfileDefinition` (line 97)
- `load_profile(name: str) -> RuntimeModel` (line 115)
- `_normalise_name(name: str) -> str` (line 44)
- `_resolve_profile_path(name: str) -> Path` (line 53)
- `_load_yaml(path: Path) -> Dict[str, Any]` (line 71)
- `_metadata_from_payload(payload: Dict[str, Any], *, default_name: str) -> ProfileMetadata` (line 83)
**Classes**
- `ProfileError` (line 13) (bases: RuntimeError)
  - None
- `ProfileNotFoundError` (line 17) (bases: ProfileError)
  - None
- `ProfileFormatError` (line 21) (bases: ProfileError)
  - None
- `ProfileMetadata` (line 26)
  - None
- `ProfileDefinition` (line 34)
  - None
**Other**
- Constant `_PROFILE_ROOT` (line 40)
- Constant `_PROFILE_SUFFIXES` (line 41)

### profiles/overrides.py
**Imports**
- Internal: `from covertreex.runtime.model import RuntimeModel`
**Functions**
- `parse_override_expression(expression: str) -> Tuple[str, Any]` (line 14)
- `parse_override_expressions(expressions: Sequence[str] | None) -> Dict[str, Any]` (line 27)
- `apply_overrides_to_model(model: RuntimeModel, overrides: Mapping[str, Any] | None) -> RuntimeModel` (line 37)
**Classes**
- `OverrideError` (line 10) (bases: ValueError)
  - None

### tests/__init__.py
**Imports**
- Internal: None
**Functions**
- None
**Classes**
- None

### tests/integration/test_parallel_delete.py
**Imports**
- Internal: `from covertreex.algo import batch_delete, batch_insert, plan_batch_delete`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
**Functions**
- `test_batch_delete_restores_parent_chain_after_tail_removal()` (line 44)
- `test_batch_delete_preserves_previous_versions()` (line 59)
- `test_plan_batch_delete_identifies_descendants()` (line 79)
- `test_batch_delete_handles_internal_node()` (line 98)
- `test_batch_delete_handles_root_removal()` (line 117)
- `test_batch_delete_supports_multiple_leaf_indices()` (line 137)
- `test_batch_delete_reassigns_descendant_subtree()` (line 152)
- `test_batch_delete_noop_for_empty_selection()` (line 166)
- `_setup_tree() -> PCCTree` (line 11)
- `_point_set(points) -> list[tuple[float, ...]]` (line 40)
**Classes**
- None

### tests/integration/test_parallel_update.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo import batch_insert, batch_insert_prefix_doubling, batch_mis_seeds, plan_batch_insert`
- Internal: `from covertreex.core._persistence_numba import NUMBA_PERSISTENCE_AVAILABLE`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend, TreeLogStats, get_runtime_backend`
**Functions**
- `test_batch_insert_numba_persistence_matches_fallback(monkeypatch: pytest.MonkeyPatch)` (line 139)
- `test_plan_batch_insert_runs_pipeline()` (line 205)
- `test_batch_insert_updates_level_offsets_and_stats()` (line 256)
- `test_batch_insert_preserves_original_tree_buffers()` (line 276)
- `test_batch_insert_only_mutates_expected_parent_nodes()` (line 296)
- `test_batch_insert_maintains_child_sibling_chains()` (line 327)
- `test_batch_insert_on_empty_tree_sets_root_level()` (line 353)
- `test_batch_insert_splices_child_chain_for_existing_parent()` (line 371)
- `test_batch_insert_sets_child_chain_for_parent_without_children()` (line 391)
- `test_batch_insert_redistributes_dominated_levels()` (line 409)
- `test_batch_insert_persistence_across_versions()` (line 471)
- `test_batch_insert_prefix_doubling_matches_manual_sequence()` (line 505)
- `_setup_tree()` (line 19)
- `_batch_in_plan_order(batch, plan)` (line 48)
- `_expected_appended_batch(batch, plan)` (line 56)
- `_expected_level_offsets(levels)` (line 67)
- `_mutated_prefix_indices(before, after, prefix_length)` (line 77)
- `_counts_from_offsets(offsets)` (line 87)
- `_expected_level_count_delta(inserted_levels, target_length)` (line 94)
- `_assert_child_sibling_consistency(tree: PCCTree) -> None` (line 107)
**Classes**
- None
**Other**
- Constant `LOG_EPS` (line 430)

### tests/integration/test_structural_core.py
**Imports**
- Internal: `from covertreex.algo import build_conflict_graph, traverse_collect_scopes`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
**Functions**
- `test_traversal_matches_naive_computation()` (line 57)
- `test_conflict_graph_matches_bruteforce_edges()` (line 105)
- `_structural_tree() -> PCCTree` (line 14)
- `_collect_chain(next_cache: np.ndarray, start: int) -> tuple[int, ...]` (line 43)
**Classes**
- None

### tests/integration/test_tier_c.py
**Imports**
- Internal: `from covertreex.algo import batch_insert`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
- Internal: `from covertreex.queries import knn`
**Functions**
- `test_async_batch_insert_harness()` (line 47)
- `_backend_array(backend, values)` (line 11)
- `_base_tree() -> PCCTree` (line 15)
**Classes**
- None

### tests/test_api_pcct.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.batch_delete import BatchDeletePlan`
- Internal: `from covertreex.algo.batch import BatchInsertPlan`
- Internal: `from covertreex.api import PCCT, Runtime, Residual`
**Functions**
- `reset_runtime_context()` (line 13)
- `test_pcct_fit_insert_knn_roundtrip()` (line 30)
- `test_pcct_delete_returns_plan()` (line 56)
- `test_pcct_fit_uses_explicit_runtime_context(monkeypatch: pytest.MonkeyPatch)` (line 66)
- `test_pcct_delete_threads_runtime_context(monkeypatch: pytest.MonkeyPatch)` (line 85)
- `_runtime() -> Runtime` (line 19)
**Classes**
- None

### tests/test_baseline_tree.py
**Imports**
- Internal: `from covertreex import BaselineCoverTree`
**Functions**
- `test_baseline_nearest_matches_bruteforce()` (line 23)
- `test_baseline_knn_matches_bruteforce()` (line 35)
- `test_baseline_knn_batched_queries()` (line 48)
- `test_baseline_knn_rejects_invalid_k()` (line 63)
- `_random_points(n: int, d: int, seed: int=0) -> np.ndarray` (line 7)
- `_bruteforce_nearest(points: np.ndarray, query: np.ndarray) -> tuple[int, float]` (line 12)
- `_bruteforce_knn(points: np.ndarray, query: np.ndarray, k: int) -> np.ndarray` (line 18)
**Classes**
- None

### tests/test_benchmarks.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.baseline import has_gpboost_cover_tree`
- Internal: `from covertreex.telemetry import BENCHMARK_BATCH_SCHEMA_ID, BENCHMARK_BATCH_SCHEMA_VERSION, BenchmarkLogWriter, RUNTIME_BREAKDOWN_SCHEMA_ID, runtime_breakdown_fieldnames`
- Internal: `from tests.utils.datasets import gaussian_points`
**Functions**
- `test_benchmark_insert_delete_smoke()` (line 34)
- `test_benchmark_knn_latency_smoke()` (line 56)
- `test_run_baseline_comparisons_sequential()` (line 71)
- `test_run_baseline_comparisons_gpboost()` (line 82)
- `test_runtime_breakdown_csv_output(tmp_path, monkeypatch)` (line 95)
- `test_benchmark_log_writer_emits_json(tmp_path)` (line 140)
- `test_batch_ops_result_artifact(tmp_path)` (line 176)
- `test_runtime_from_args_residual_lookup()` (line 220)
- `test_runtime_from_args_euclidean_defaults()` (line 250)
- `_ensure_euclidean_metric(monkeypatch: pytest.MonkeyPatch)` (line 27)
- `_cli_args(**overrides)` (line 203)
**Classes**
- None

### tests/test_cli_querier_guard.py
**Imports**
- Internal: `from cli.queries.app import app, enable_legacy_entrypoint_warning`
**Functions**
- `test_cli_allows_euclidean_with_gate_off(tmp_path: Path, monkeypatch) -> None` (line 10)
**Classes**
- None

### tests/test_cli_queries_telemetry.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from cli.queries.telemetry import CLITelemetryHandles, ResidualTraversalTelemetry, initialise_cli_telemetry`
**Functions**
- `test_summary_reports_pairwise_reuse_line() -> None` (line 35)
- `test_observe_plan_raises_when_pairwise_missing(capsys: pytest.CaptureFixture[str]) -> None` (line 47)
- `test_initialise_cli_telemetry_creates_log(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None` (line 58)
- `test_initialise_cli_telemetry_scope_caps(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None` (line 84)
**Classes**
- `_DummyTimings` (line 17)
  - None
- `_DummyPlan` (line 26)
  - `__init__(self, *, pairwise_reused: int) -> None` (line 27)

### tests/test_config.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.api import Residual, Runtime`
- Internal: `from cli.runtime import runtime_from_args`
**Functions**
- `test_runtime_config_defaults(monkeypatch: pytest.MonkeyPatch)` (line 52)
- `test_runtime_context_uses_numpy_backend_by_default(monkeypatch: pytest.MonkeyPatch)` (line 93)
- `test_precision_override(monkeypatch: pytest.MonkeyPatch)` (line 102)
- `test_device_fallback_to_cpu(monkeypatch: pytest.MonkeyPatch)` (line 113)
- `test_invalid_backend(monkeypatch: pytest.MonkeyPatch)` (line 125)
- `test_mis_seed_parsing(monkeypatch: pytest.MonkeyPatch)` (line 134)
- `test_disable_diagnostics_flag(monkeypatch: pytest.MonkeyPatch)` (line 143)
- `test_runtime_config_from_env_matches_cached(monkeypatch: pytest.MonkeyPatch)` (line 152)
- `test_describe_runtime_reports_expected_fields(monkeypatch: pytest.MonkeyPatch)` (line 165)
- `test_conflict_graph_impl_override(monkeypatch: pytest.MonkeyPatch)` (line 201)
- `test_runtime_context_manager_restores_previous(monkeypatch: pytest.MonkeyPatch)` (line 210)
- `test_runtime_activate_context_manager(monkeypatch: pytest.MonkeyPatch)` (line 224)
- `test_conflict_graph_impl_grid(monkeypatch: pytest.MonkeyPatch)` (line 244)
- `test_residual_scope_cap_env(monkeypatch: pytest.MonkeyPatch, tmp_path)` (line 253)
- `test_residual_level_cache_batching_env(monkeypatch: pytest.MonkeyPatch)` (line 266)
- `test_residual_grid_whiten_scale_env(monkeypatch: pytest.MonkeyPatch)` (line 276)
- `test_batch_order_override(monkeypatch: pytest.MonkeyPatch)` (line 285)
- `test_seed_pack_env_overrides(monkeypatch: pytest.MonkeyPatch)` (line 296)
- `test_prefix_schedule_override(monkeypatch: pytest.MonkeyPatch)` (line 307)
- `test_scope_segment_dedupe_toggle(monkeypatch: pytest.MonkeyPatch)` (line 326)
- `test_scope_chunk_target_override(monkeypatch: pytest.MonkeyPatch)` (line 335)
- `test_scope_chunk_target_disable(monkeypatch: pytest.MonkeyPatch)` (line 344)
- `test_scope_chunk_max_segments_override(monkeypatch: pytest.MonkeyPatch)` (line 353)
- `test_scope_chunk_max_segments_disable(monkeypatch: pytest.MonkeyPatch)` (line 362)
- `test_degree_cap_default(monkeypatch: pytest.MonkeyPatch)` (line 371)
- `test_degree_cap_override(monkeypatch: pytest.MonkeyPatch)` (line 379)
- `test_scope_budget_schedule_parsing(monkeypatch: pytest.MonkeyPatch)` (line 388)
- `test_scope_budget_schedule_requires_increasing(monkeypatch: pytest.MonkeyPatch)` (line 401)
- `test_metric_override(monkeypatch: pytest.MonkeyPatch)` (line 410)
- `test_residual_defaults_enable_gate_and_doubling(monkeypatch: pytest.MonkeyPatch)` (line 419)
- `test_sparse_traversal_toggle(monkeypatch: pytest.MonkeyPatch)` (line 437)
- `test_runtime_from_args_defaults_sparse_numba_for_residual(monkeypatch: pytest.MonkeyPatch)` (line 446)
- `test_runtime_from_args_degree_cap_override(monkeypatch: pytest.MonkeyPatch)` (line 479)
- `test_runtime_from_args_seed_pack_overrides(monkeypatch: pytest.MonkeyPatch)` (line 493)
- `test_runtime_extra_fields_feed_runtime_model(monkeypatch: pytest.MonkeyPatch)` (line 509)
- `test_residual_gate1_env_overrides(monkeypatch: pytest.MonkeyPatch)` (line 519)
- `_clear_env(monkeypatch: pytest.MonkeyPatch) -> None` (line 13)
**Classes**
- None

### tests/test_conflict_graph.py
**Imports**
- Internal: `from covertreex.metrics import residual`
- Internal: `from covertreex.algo.conflict import ConflictGraph, build_conflict_graph`
- Internal: `from covertreex.algo.conflict import runner`
- Internal: `from covertreex.algo.traverse import traverse_collect_scopes`
- Internal: `from covertreex.api import Residual, Runtime`
- Internal: `from covertreex.core.metrics import reset_residual_metric`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
- Internal: `from covertreex.algo import batch_insert`
- Internal: `from covertreex.algo._scope_numba import NUMBA_SCOPE_AVAILABLE, _chunk_ranges_from_indptr`
- Internal: `from covertreex.metrics.residual import ResidualCorrHostData, configure_residual_correlation, set_residual_backend`
- Internal: `from covertreex.exceptions import ResidualPairwiseCacheError`
- Internal: `from covertreex import config`
**Functions**
- `reset_runtime_context() -> None` (line 28)
- `test_chunk_range_builder_honours_max_segments()` (line 56)
- `test_chunk_range_builder_clamps_when_chunk_target_disabled()` (line 74)
- `test_chunk_range_builder_skips_zero_volume_segments_with_keep_mask()` (line 85)
- `test_chunk_range_builder_pair_merge_merges_segments()` (line 101)
- `test_conflict_graph_builds_edges_from_shared_scopes()` (line 124)
- `test_segmented_conflict_graph_matches_dense(monkeypatch: pytest.MonkeyPatch)` (line 159)
- `test_chunked_conflict_graph_matches_dense(monkeypatch: pytest.MonkeyPatch)` (line 185)
- `test_conflict_graph_prefers_explicit_context(monkeypatch: pytest.MonkeyPatch)` (line 219)
- `test_degree_cap_limits_conflict_edges(monkeypatch: pytest.MonkeyPatch)` (line 262)
- `test_conflict_builder_buffer_reuse_reports_arena_bytes(monkeypatch: pytest.MonkeyPatch)` (line 294)
- `test_residual_conflict_graph_matches_dense(monkeypatch: pytest.MonkeyPatch)` (line 318)
- `test_residual_conflict_graph_reuses_pairwise_cache(monkeypatch: pytest.MonkeyPatch)` (line 402)
- `test_residual_conflict_graph_reuse_across_chunk_targets(monkeypatch: pytest.MonkeyPatch, chunk_target: int) -> None` (line 498)
- `test_residual_conflict_graph_requires_pairwise_cache(monkeypatch: pytest.MonkeyPatch)` (line 560)
- `test_grid_conflict_builder_forces_leaders(monkeypatch: pytest.MonkeyPatch)` (line 627)
- `test_residual_grid_conflict_builder_emits_leaders(monkeypatch: pytest.MonkeyPatch)` (line 659)
- `test_residual_grid_uses_whitened_scale_without_gate(monkeypatch: pytest.MonkeyPatch)` (line 729)
- `test_adaptive_chunk_target_triggers_on_sparse_scopes()` (line 824)
- `test_adaptive_chunk_target_skips_dense_scopes()` (line 832)
- `test_batch_insert_clamps_infinite_si_cache()` (line 838)
- `_sample_tree()` (line 34)
**Classes**
- None

### tests/test_determinism_runtime.py
**Imports**
- Internal: `from covertreex.algo import batch_insert`
- Internal: `from covertreex.api import Runtime`
- Internal: `from covertreex.core.tree import PCCTree`
- Internal: `from covertreex.telemetry import BenchmarkLogWriter`
**Functions**
- `test_repeated_runs_share_tree_and_hash(tmp_path)` (line 67)
- `_gaussian_points(*, dimension: int, tree_points: int) -> np.ndarray` (line 14)
- `_tree_snapshot(tree) -> dict[str, np.ndarray]` (line 19)
- `_run_once(tmp_path: Path, *, run_id: str, points: np.ndarray)` (line 29)
**Classes**
- None

### tests/test_export_benchmark_diagnostics.py
**Imports**
- Internal: `from tools import export_benchmark_diagnostics`
**Functions**
- `test_aggregate_requires_pairwise_reuse_for_residual() -> None` (line 6)
- `test_aggregate_allows_non_residual_without_reuse() -> None` (line 16)
**Classes**
- None

### tests/test_external_baseline.py
**Imports**
- Internal: `from covertreex import ExternalCoverTreeBaseline, has_external_cover_tree`
**Functions**
- `test_external_baseline_knn_matches_bruteforce()` (line 10)
- `test_external_baseline_nearest()` (line 30)
**Classes**
- None

### tests/test_knn.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
- Internal: `from covertreex.queries import knn, nearest_neighbor`
**Functions**
- `test_knn_matches_bruteforce_distances()` (line 42)
- `test_nearest_neighbor_handles_single_query_vector()` (line 60)
- `test_knn_raises_for_empty_tree()` (line 70)
- `test_knn_prefers_lower_indices_on_ties()` (line 78)
- `test_knn_returns_all_points_when_k_equals_size()` (line 87)
- `test_knn_multi_query_batch_shapes()` (line 102)
- `test_knn_numba_matches_python(monkeypatch)` (line 112)
- `_build_tree()` (line 12)
**Classes**
- None

### tests/test_logging.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.api import Runtime`
- Internal: `from covertreex.logging import get_logger`
**Functions**
- `test_logger_respects_runtime_level(monkeypatch: pytest.MonkeyPatch)` (line 10)
**Classes**
- None

### tests/test_logging_diagnostics.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.api import Runtime, Residual`
- Internal: `from covertreex.algo import batch_delete, batch_insert`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
- Internal: `from covertreex.queries import knn`
**Functions**
- `test_batch_insert_emits_resource_log(caplog: pytest.LogCaptureFixture) -> None` (line 55)
- `test_batch_delete_emits_resource_log(caplog: pytest.LogCaptureFixture) -> None` (line 77)
- `test_knn_emits_resource_log(caplog: pytest.LogCaptureFixture) -> None` (line 98)
- `test_diagnostics_can_be_disabled(caplog: pytest.LogCaptureFixture, monkeypatch: pytest.MonkeyPatch) -> None` (line 119)
- `_diagnostics_runtime(*, diagnostics: bool | None=True) -> Runtime` (line 15)
- `_make_tree() -> PCCTree` (line 26)
**Classes**
- None

### tests/test_metrics.py
**Imports**
- Internal: `from covertreex.core.metrics import available_metrics, configure_residual_metric, get_metric, MetricRegistry, Metric, reset_residual_metric`
- Internal: `from covertreex.core.tree import TreeBackend, get_runtime_backend`
- Internal: `from covertreex.metrics.residual import ResidualCorrHostData, ResidualDistanceTelemetry, ResidualGateLookup, ResidualGateProfile, ResidualWorkspace, build_residual_backend, compute_whitened_block, configure_residual_correlation, compute_residual_distances_with_radius, compute_residual_distances, compute_residual_distances_with_kernel, compute_residual_distances_from_kernel, compute_residual_lower_bounds_from_kernel, compute_residual_pairwise_matrix, get_residual_backend, set_residual_backend`
**Functions**
- `test_euclidean_pairwise_matches_manual()` (line 38)
- `test_euclidean_pointwise_supports_vector_inputs()` (line 51)
- `test_metric_registry_registers_and_retrieves()` (line 64)
- `test_get_metric_unknown_raises()` (line 89)
- `test_available_metrics_contains_euclidean()` (line 94)
- `test_residual_metric_requires_configuration()` (line 100)
- `test_residual_distance_chunk_respects_radius()` (line 128)
- `test_sgemm_kernel_provider_matches_reference()` (line 205)
- `test_force_whitened_records_pairs_when_gate_disabled()` (line 241)
- `test_residual_gate1_prunes_far_candidates()` (line 312)
- `test_residual_gate_audit_remains_clean(tmp_path)` (line 412)
- `test_residual_pairwise_matrix_records_telemetry()` (line 497)
- `test_residual_backend_uses_float32_staging()` (line 547)
- `test_compute_whitened_block_matches_reference()` (line 579)
- `test_residual_gate_profile_records_samples(tmp_path)` (line 635)
- `test_residual_gate_lookup_thresholds_monotonic(tmp_path)` (line 659)
- `test_residual_correlation_helper_computes_distances()` (line 678)
- `test_residual_distance_and_bounds_reuse_kernel_blocks()` (line 745)
**Classes**
- None

### tests/test_mis.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.conflict import build_conflict_graph`
- Internal: `from covertreex.algo.mis import MISResult, batch_mis_seeds, run_mis`
- Internal: `from covertreex.algo.traverse import traverse_collect_scopes`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
**Functions**
- `test_run_mis_produces_independent_set()` (line 36)
- `test_batch_mis_seeds_deterministic(monkeypatch: pytest.MonkeyPatch)` (line 65)
- `test_batch_mis_seeds_rejects_negative()` (line 80)
- `test_run_mis_numba_matches_jax(monkeypatch: pytest.MonkeyPatch)` (line 85)
- `_build_tree()` (line 14)
**Classes**
- None

### tests/test_pcct_cli.py
**Imports**
- Internal: `from cli.pcct import app`
- Internal: `from cli.queries.app import disable_legacy_entrypoint_warning, enable_legacy_entrypoint_warning`
- Internal: `from cli.queries.benchmark import QueryBenchmarkResult`
**Functions**
- `test_pcct_profile_list_displays_profiles() -> None` (line 32)
- `test_pcct_profile_describe_outputs_json() -> None` (line 41)
- `test_pcct_query_subcommand_suppresses_legacy_warning(monkeypatch) -> None` (line 50)
- `test_pcct_doctor_reports_environment(tmp_path) -> None` (line 67)
- `test_pcct_query_command_invokes_runner(monkeypatch) -> None` (line 75)
- `test_pcct_query_manual_runtime_knobs(monkeypatch) -> None` (line 103)
- `test_pcct_query_requires_profile_for_overrides(monkeypatch) -> None` (line 155)
- `test_pcct_build_command_invokes_builder(monkeypatch) -> None` (line 170)
- `test_pcct_benchmark_repeats_runs(monkeypatch) -> None` (line 187)
- `test_pcct_telemetry_render_command(tmp_path) -> None` (line 231)
- `test_pcct_query_seeds_override_produces_stable_hash(tmp_path) -> None` (line 296)
- `_fake_benchmark_run()` (line 24)
**Classes**
- `_DummyRun` (line 14)
  - None

### tests/test_pcct_variants.py
**Imports**
- Internal: `from covertreex import config, reset_residual_metric`
- Internal: `from covertreex.api import PCCT, Runtime`
- Internal: `from covertreex.metrics import build_residual_backend, configure_residual_correlation`
**Functions**
- `reset_runtime_context() -> None` (line 21)
- `residual_backend_config() -> None` (line 28)
- `test_knn_consistency_across_batch_orders() -> None` (line 63)
- `test_knn_consistency_enable_numba_toggle() -> None` (line 79)
- `test_knn_consistency_batch_order() -> None` (line 89)
- `test_knn_consistency_sparse_toggle() -> None` (line 99)
- `test_knn_consistency_residual_whitened_toggle() -> None` (line 110)
- `test_knn_consistency_residual_scope_member_limit() -> None` (line 129)
- `test_knn_consistency_residual_bitset_toggle() -> None` (line 161)
- `test_knn_consistency_residual_dense_streamer_toggle() -> None` (line 172)
- `test_knn_consistency_residual_masked_append_toggle() -> None` (line 183)
- `test_knn_consistency_residual_sparse_toggle() -> None` (line 194)
- `_knn_result(runtime: Runtime, *, queries: np.ndarray | None=None, k: int=K) -> tuple[np.ndarray, np.ndarray]` (line 42)
- `_base_runtime() -> Runtime` (line 53)
- `_assert_knn_equal(a_idx: np.ndarray, a_dist: np.ndarray, b_idx: np.ndarray, b_dist: np.ndarray) -> None` (line 74)
- `_residual_runtime(**overrides: Any) -> Runtime` (line 146)
**Classes**
- None
**Other**
- Constant `POINTS` (line 15)
- Constant `QUERIES` (line 16)
- Constant `K` (line 17)

### tests/test_persistence.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core import persistence`
- Internal: `from covertreex.core.persistence import SliceUpdate, apply_persistence_journal, build_persistence_journal, clone_array_segment, clone_tree_with_updates`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend, TreeLogStats, compute_level_offsets, get_runtime_backend`
**Functions**
- `test_clone_array_segment_preserves_original()` (line 44)
- `test_clone_tree_with_updates_replaces_values()` (line 55)
- `test_build_persistence_journal_tracks_head_updates()` (line 70)
- `test_apply_persistence_journal_numpy(monkeypatch, enable_numba)` (line 106)
- `_build_tree(backend: TreeBackend | None=None)` (line 22)
**Classes**
- None

### tests/test_pipeline_placeholder.py
**Imports**
- Internal: `from covertreex.algo import build_conflict_graph, run_mis, traverse_collect_scopes`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
**Functions**
- `test_placeholder_pipeline_executes()` (line 36)
- `_sample_tree()` (line 14)
**Classes**
- None

### tests/test_plugins.py
**Imports**
- Internal: `from cli.pcct import app`
- Internal: `from covertreex.algo.conflict.strategies import register_conflict_strategy, deregister_conflict_strategy, select_conflict_strategy`
- Internal: `from covertreex.algo.traverse.base import TraversalStrategy`
- Internal: `from covertreex.algo.traverse.strategies.registry import deregister_traversal_strategy, registered_traversal_strategies`
- Internal: `from covertreex.plugins import traversal`
- Internal: `from covertreex.plugins import conflict`
- Internal: `from covertreex.plugins import metrics`
- Internal: `from covertreex.core.metrics import Metric, _REGISTRY, get_metric`
- Internal: `from covertreex.algo.conflict.base import ConflictGraphContext, ConflictGraphStrategy`
**Functions**
- `test_traversal_entrypoint_loader(monkeypatch) -> None` (line 44)
- `test_conflict_predicate_exception_falls_back(monkeypatch) -> None` (line 64)
- `test_metric_entrypoint_loader(monkeypatch) -> None` (line 79)
- `test_cli_plugins_list_reports_entries() -> None` (line 101)
**Classes**
- `FakeEntryPoint` (line 25)
  - `load(self)` (line 30)
  - `__init__(self, name: str, payload)` (line 26)
- `_DummyTraversal` (line 34) (bases: TraversalStrategy)
  - `collect(self, tree, batch, *, backend, runtime)` (line 35)
- `_DummyConflict` (line 39) (bases: ConflictGraphStrategy)
  - `build(self, ctx: ConflictGraphContext)` (line 40)

### tests/test_profiles_loader.py
**Imports**
- Internal: `from covertreex.api import Runtime`
- Internal: `from profiles import ProfileNotFoundError, apply_overrides_to_model, available_profiles, load_profile, parse_override_expression, parse_override_expressions`
**Functions**
- `test_available_profiles_exposes_expected_entries() -> None` (line 14)
- `test_load_profile_returns_runtime_model() -> None` (line 19)
- `test_load_profile_missing_raises() -> None` (line 26)
- `test_override_parser_supports_numbers() -> None` (line 31)
- `test_apply_overrides_to_model_updates_nested_fields() -> None` (line 37)
- `test_runtime_from_profile_accepts_override_expressions() -> None` (line 47)
**Classes**
- None

### tests/test_property_strategies.py
**Imports**
- Internal: `from covertreex.algo.mis import batch_mis_seeds`
- Internal: `from covertreex.algo.order.strategy import compute_batch_order`
**Functions**
- `test_batch_order_returns_valid_permutation(points: np.ndarray, strategy: str) -> None` (line 22)
- `test_batch_mis_seeds_are_deterministic(count: int, seed: int) -> None` (line 37)
**Classes**
- None

### tests/test_residual_gate_profile_ingest.py
**Imports**
- Internal: `from tools.ingest_residual_gate_profile import load_profile_records, merge_profile_records`
**Functions**
- `test_merge_profile_records(tmp_path: Path) -> None` (line 31)
- `_sample_record(run_id: str, max_scale: float) -> dict` (line 14)
**Classes**
- None

### tests/test_residual_guardrail_check.py
**Imports**
- Internal: `from tools import residual_guardrail_check`
**Functions**
- `test_parse_guardrail_metrics(tmp_path: Path) -> None` (line 18)
- `test_evaluate_metrics_reports_failures() -> None` (line 47)
- `_write_log(tmp_path: Path, records: list[dict]) -> Path` (line 10)
**Classes**
- None

### tests/test_residual_parents.py
**Imports**
- Internal: `from covertreex.algo.traverse.strategies import residual`
- Internal: `from covertreex.metrics.residual import ResidualCorrHostData, ResidualDistanceTelemetry, ResidualWorkspace`
**Functions**
- `test_residual_parent_search_skips_whitened_path_when_gate_disabled() -> None` (line 52)
- `test_scope_streaming_respects_force_whitened_flag(monkeypatch: pytest.MonkeyPatch) -> None` (line 79)
- `test_resolve_scope_limits_dense_fallback() -> None` (line 131)
- `test_resolve_scope_limits_respects_override() -> None` (line 141)
- `test_resolve_scope_limits_gate_on_skips_fallback() -> None` (line 151)
- `test_parallel_streaming_honors_stream_tile_override() -> None` (line 161)
- `test_parallel_streaming_tiles_with_scope_limit() -> None` (line 192)
- `test_level_cache_prefetch_batches_queries() -> None` (line 223)
- `test_residual_collect_next_chain_tracks_sequence() -> None` (line 280)
- `test_parallel_streaming_dynamic_tile_respects_budget() -> None` (line 293)
- `test_parallel_streaming_uses_numba_scope_append(monkeypatch: pytest.MonkeyPatch) -> None` (line 326)
- `test_parallel_streaming_masked_append_toggle(monkeypatch: pytest.MonkeyPatch) -> None` (line 371)
- `test_parallel_streaming_masked_append_supports_bitset(monkeypatch: pytest.MonkeyPatch) -> None` (line 418)
- `test_compute_dynamic_tile_stride_delegates_to_numba(monkeypatch: pytest.MonkeyPatch) -> None` (line 450)
- `test_update_scope_budget_state_delegates_to_numba(monkeypatch: pytest.MonkeyPatch) -> None` (line 473)
- `test_residual_scope_append_masked_appends_members() -> None` (line 502)
- `test_append_scope_positions_masked_prefers_numba_helper(monkeypatch: pytest.MonkeyPatch) -> None` (line 526)
- `test_append_scope_positions_bitset_uses_numba_helper(monkeypatch: pytest.MonkeyPatch) -> None` (line 558)
- `test_append_scope_positions_masked_prefers_bitset_helper(monkeypatch: pytest.MonkeyPatch) -> None` (line 591)
- `_build_host_backend(chunk_size: int=2) -> ResidualCorrHostData` (line 16)
- `_dummy_tree(num_points: int=3) -> SimpleNamespace` (line 72)
**Classes**
- None

### tests/test_residual_scope_caps.py
**Imports**
- Internal: `from covertreex.metrics.residual.scope_caps import ResidualScopeCapTable, get_scope_cap_table, reset_scope_cap_cache`
**Functions**
- `test_scope_cap_table_lookup_applies_levels(tmp_path)` (line 13)
- `test_scope_cap_cache_returns_same_instance(tmp_path)` (line 41)
**Classes**
- None

### tests/test_run_reference_benchmarks.py
**Imports**
- Internal: `from tools import run_reference_benchmarks`
**Functions**
- `test_query_job_build_command(tmp_path: Path) -> None` (line 9)
- `test_guardrail_job_build_command(tmp_path: Path) -> None` (line 25)
- `test_select_jobs_handles_unknown() -> None` (line 39)
**Classes**
- None

### tests/test_runtime_callsite_audit.py
**Imports**
- Internal: None
**Functions**
- `test_runtime_config_call_sites_are_explicit() -> None` (line 5)
**Classes**
- None

### tests/test_scope_numba.py
**Imports**
- Internal: `from covertreex.algo._scope_numba import NUMBA_SCOPE_AVAILABLE, build_scope_csr_from_pairs`
**Functions**
- `test_scope_builder_limits_and_orders_with_levels()` (line 15)
- `test_scope_builder_limits_without_levels()` (line 36)
- `test_scope_builder_orders_full_row_when_limit_disabled()` (line 47)
**Classes**
- None

### tests/test_semisort.py
**Imports**
- Internal: `from covertreex.algo import group_by_int, select_topk_by_level`
- Internal: `from covertreex.core.tree import get_runtime_backend`
**Functions**
- `test_group_by_int_basic()` (line 10)
- `test_group_by_int_empty()` (line 30)
- `test_select_topk_by_level_applies_limit()` (line 43)
- `test_select_topk_by_level_orders_full_when_unlimited()` (line 52)
**Classes**
- None

### tests/test_traverse.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.algo.traverse import TraversalResult, traverse_collect_scopes`
- Internal: `from covertreex.algo.traverse import runner`
- Internal: `from covertreex.api import Residual, Runtime`
- Internal: `from covertreex.core.metrics import reset_residual_metric`
- Internal: `from covertreex.core.tree import PCCTree, TreeLogStats, get_runtime_backend`
- Internal: `from covertreex.metrics.residual import ResidualCorrHostData, configure_residual_correlation, set_residual_backend`
**Functions**
- `reset_runtime_context() -> None` (line 23)
- `test_traversal_assigns_nearest_parent()` (line 84)
- `test_traversal_uses_tree_backend_by_default()` (line 113)
- `test_traversal_handles_empty_tree()` (line 130)
- `test_traversal_semisorts_scopes_by_level()` (line 145)
- `test_euclidean_scope_chunk_target_limits_scopes(monkeypatch: pytest.MonkeyPatch)` (line 182)
- `test_sparse_traversal_matches_dense(monkeypatch: pytest.MonkeyPatch)` (line 202)
- `test_traversal_prefers_explicit_context(monkeypatch: pytest.MonkeyPatch)` (line 211)
- `test_residual_scope_limit_applies_scope_chunk_target(monkeypatch: pytest.MonkeyPatch)` (line 246)
- `test_residual_scope_cache_hits(monkeypatch: pytest.MonkeyPatch)` (line 318)
- `test_residual_scope_chunk_target_caps_scan_points(monkeypatch: pytest.MonkeyPatch)` (line 368)
- `test_residual_scope_budget_scheduler(monkeypatch: pytest.MonkeyPatch)` (line 436)
- `test_residual_sparse_traversal_matches_dense(monkeypatch: pytest.MonkeyPatch)` (line 489)
- `test_residual_scope_caps_limit_radii(monkeypatch: pytest.MonkeyPatch)` (line 585)
- `test_residual_scope_caps_file_overrides_default(monkeypatch: pytest.MonkeyPatch, tmp_path)` (line 633)
- `_sample_tree()` (line 29)
- `_install_stub_residual_backend(chunk_size: int=2) -> None` (line 51)
**Classes**
- None

### tests/test_tree.py
**Imports**
- Internal: `from covertreex import config`
- Internal: `from covertreex.core.tree import PCCTree, TreeBackend, TreeLogStats, get_runtime_backend`
**Functions**
- `test_empty_tree_has_expected_shapes()` (line 40)
- `test_replace_returns_new_instance()` (line 49)
- `test_materialise_roundtrip()` (line 58)
- `test_to_backend_respects_precision()` (line 66)
- `test_tree_backend_rejects_precision()` (line 73)
- `_sample_tree() -> PCCTree` (line 18)
**Classes**
- None

### tests/utils/__init__.py
Shared test utilities for covertreex.
**Imports**
- Internal: `from .datasets import gaussian_dataset, gaussian_points, rbf_kernel`
**Functions**
- None
**Classes**
- None

### tests/utils/datasets.py
**Imports**
- Internal: None
**Functions**
- `gaussian_points(rng: Generator | None, count: int, dimension: int, *, dtype: np.dtype | type[np.floating]=np.float64) -> Array` (line 15)
- `gaussian_dataset(rng: Generator | None, *, tree_points: int, queries: int, dimension: int, dtype: np.dtype | type[np.floating]=np.float64) -> Tuple[Array, Array]` (line 31)
- `rbf_kernel(x: Array, y: Array, *, variance: float, lengthscale: float) -> Array` (line 47)
- `_ensure_rng(rng: Generator | None) -> Generator` (line 11)
**Classes**
- None

### tools/__init__.py
Helper scripts for covertreex development and benchmarking.
**Imports**
- Internal: None
**Functions**
- None
**Classes**
- None

### tools/build_residual_gate_profile.py
**Imports**
- Internal: `from covertreex.api import Residual, Runtime`
- Internal: `from covertreex.core.metrics import reset_residual_metric`
- Internal: `from covertreex.metrics import build_residual_backend`
- Internal: `from covertreex.metrics.residual import ResidualGateProfile, compute_residual_distances_from_kernel, configure_residual_correlation`
- Internal: `from covertreex.telemetry import generate_run_id, resolve_artifact_path`
- Internal: `from tests.utils.datasets import gaussian_points`
**Functions**
- `main() -> None` (line 99)
- `_parse_args() -> argparse.Namespace` (line 21)
- `_build_backend(args: argparse.Namespace)` (line 50)
- `_record_pairs(backend, profile: ResidualGateProfile, pair_chunk: int) -> None` (line 64)
**Classes**
- None
**Other**
- `if __name__ == '__main__'` guard (line 140)

### tools/export_benchmark_diagnostics.py
**Imports**
- Internal: None
**Functions**
- `main() -> None` (line 102)
- `_load_records(path: Path) -> List[Dict[str, Any]]` (line 11)
- `_detect_metric(records: Iterable[Dict[str, Any]]) -> str | None` (line 27)
- `_aggregate(records: Iterable[Dict[str, Any]]) -> Dict[str, Any]` (line 35)
**Classes**
- None
**Other**
- `if __name__ == '__main__'` guard (line 170)

### tools/ingest_residual_gate_profile.py
**Imports**
- Internal: `from covertreex.telemetry.schemas import RESIDUAL_GATE_PROFILE_SCHEMA_ID`
**Functions**
- `load_profile_records(paths: List[str]) -> List[ProfileRecord]` (line 126)
- `merge_profile_records(records: List[ProfileRecord], *, metadata_overrides: Dict[str, Any] | None=None) -> Dict[str, Any]` (line 139)
- `main(argv: List[str] | None=None) -> int` (line 253)
- `_coerce_array(values: Iterable[Any], name: str) -> np.ndarray` (line 34)
- `_coerce_counts(values: Iterable[Any], name: str) -> np.ndarray` (line 41)
- `_iter_payloads(path: Path) -> Iterator[Dict[str, Any]]` (line 48)
- `_extract_profile(record: Dict[str, Any], *, source: Path) -> ProfileRecord | None` (line 74)
- `_parse_metadata(pairs: List[str]) -> Dict[str, Any]` (line 220)
- `_build_arg_parser() -> argparse.ArgumentParser` (line 230)
**Classes**
- `ProfileRecord` (line 18)
  - None
**Other**
- `if __name__ == '__main__'` guard (line 277)

### tools/residual_guardrail_check.py
Run the 4k residual guardrail benchmark and enforce the documented thresholds.
**Imports**
- Internal: None
**Functions**
- `parse_guardrail_metrics(path: Path) -> GuardrailMetrics` (line 94)
- `evaluate_metrics(metrics: GuardrailMetrics, *, min_whitened_coverage: float, max_median_semisort_ms: float, require_gate1_prunes: bool, require_pairwise_reuse: bool, min_dominated_batches: int) -> List[str]` (line 123)
- `main(argv: Sequence[str] | None=None) -> int` (line 175)
- `_default_log_path() -> Path` (line 52)
- `_build_cli_command(args: argparse.Namespace, log_path: Path) -> List[str]` (line 57)
- `_load_records(path: Path) -> Iterable[dict]` (line 85)
- `_write_summary(path: Path, metrics: GuardrailMetrics) -> None` (line 158)
**Classes**
- `GuardrailMetrics` (line 29)
  - `whitened_coverage(self) -> float` (line 38)
  - `all_pairwise_reused(self) -> bool` (line 44)
  - `semisort_median_seconds(self) -> float` (line 48)
**Other**
- `if __name__ == '__main__'` guard (line 272)

### tools/residual_scaling_sweep.py
Run residual benchmarks across multiple tree sizes.
**Imports**
- Internal: None
**Functions**
- `parse_args() -> argparse.Namespace` (line 16)
- `main() -> None` (line 110)
- `_summary_from_log(path: Path) -> tuple[float, float, float, int]` (line 51)
- `_run_size(size: int, args: argparse.Namespace) -> Path` (line 79)
**Classes**
- None
**Other**
- Constant `DEFAULT_SIZES` (line 13)
- `if __name__ == '__main__'` guard (line 133)

### tools/run_reference_benchmarks.py
Automate the reference PCCT benchmark suite and emit JSONL/CSV artefacts.
**Imports**
- Internal: None
**Functions**
- `main(argv: Sequence[str] | None=None) -> int` (line 261)
- `_default_output_dir() -> Path` (line 108)
- `_jobs() -> Dict[str, BenchmarkJob]` (line 113)
- `_export_csv(log_path: Path, csv_path: Path, python_executable: str) -> None` (line 213)
- `_run_job(job: BenchmarkJob, log_path: Path, csv_path: Path, env: Dict[str, str], python_executable: str, skip_existing: bool) -> Dict[str, str]` (line 226)
- `_select_jobs(all_jobs: Dict[str, BenchmarkJob], names: Sequence[str] | None) -> Iterable[BenchmarkJob]` (line 250)
**Classes**
- `BenchmarkJob` (line 35)
  - `build_command(self, log_path: Path, python_executable: str) -> List[str]` (line 51)
  - `metadata(self) -> Dict[str, object]` (line 91)
**Other**
- Constant `TOOLS_DIR` (line 25)
- Constant `REPO_ROOT` (line 26)
- Constant `DEFAULT_OUTPUT_BASE` (line 27)
- Constant `DEFAULT_ENV` (line 28)
- `if __name__ == '__main__'` guard (line 305)

## 3. Architecture & Notable Observations

- **PCCT data flow** – The `PCCT` facade orchestrates tree creation, batch insert/delete, and query paths (`covertreex/api/pcct.py:45`) by invoking order planning (`covertreex/algo/batch/insert.py:136`), traversal strategy selection (`covertreex/algo/traverse/runner.py:25`), conflict graph materialisation (`covertreex/algo/conflict/runner.py:58`), and MIS selection kernels (`covertreex/algo/mis.py:73`). Copy-on-write tree persistence and journaling (`covertreex/core/persistence.py:35`, `covertreex/core/persistence.py:174`) keep updates immutable, while `covertreex/baseline.py:264` maintains slower reference implementations for validation.
- **Runtime contexts and profiles** – A thread-local runtime stack (`covertreex/runtime/config.py:19`) and expansive env-model defaults (`covertreex/runtime/model.py:12`, `covertreex/runtime/model.py:296`) feed into API-friendly configuration/override helpers (`covertreex/api/runtime.py:130`). YAML-driven profiles plus override parsing (`profiles/loader.py:97`, `profiles/overrides.py:14`) mean CLI/automation code always resolves to a well-typed `RuntimeModel` before activation.
- **Residual metric + telemetry surface** – Residual correlation caches (`covertreex/metrics/residual/core.py:53`) plug directly into traversal/conflict builders when the runtime metric toggles to residual mode (`covertreex/algo/conflict/runner.py:58`). Benchmark runs wrap runtime activation, telemetry writers, and artifact resolution via `BenchmarkRun` (`cli/pcct/execution.py:23`) and the log/artifact helpers (`covertreex/telemetry/logs.py:126`, `covertreex/telemetry/artifacts.py:22`), ensuring batch plans, scope caps, and resource data are persisted per run ID.
- **Plugin + CLI layering** – The Typer multi-app (`cli/pcct/main.py:21`) stitches together profile inspection, benchmarking, telemetry, and legacy commands while continuing to load plugin entrypoints for traversal/conflict/metric extensions (`covertreex/plugins/_loader.py:22`). The retained `cli/queries/app.py:16` indicates progressive migration: both CLIs share runtime/telemetry code and can co-exist for compatibility audits.
- **Tooling/test coupling** – Several operational tools import test utilities (e.g., dataset generators reused by `tools/build_residual_gate_profile.py:18` and `cli/runtime_breakdown.py:28` pulling from `tests/utils/datasets.py:15`), which keeps synthetic data generation DRY but means shipped scripts assume access to the `tests` package—worth documenting if packaging these tools separately.
- **Optional backends & duplicate kernels** – Many kernels are defined twice to gate optional dependencies (`covertreex/algo/_residual_scope_numba.py:17` and `covertreex/algo/_scope_numba.py:12` expose both numba and pure-Python fallbacks), and array backends still include an unimplemented GPU stub (`covertreex/core/tree.py:59`). This keeps the code runnable without numba/JAX but increases maintenance burden; tests such as `test_batch_insert_numba_persistence_matches_fallback` (`tests/integration/test_parallel_update.py:139`) mitigate drift.
- **Telemetry & guardrails** – Tooling like the reference benchmark runner (`tools/run_reference_benchmarks.py:261`) and residual guardrail/profiling scripts rely on the same runtime/telemetry primitives, and tests assert guardrail parsing (`tests/test_residual_guardrail_check.py:12`) plus CLI log creation (`tests/test_cli_queries_telemetry.py:58`), signaling a strong focus on observability baked into the architecture.
